<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX0">
		<Properties>
			<bool name="Archivable">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>0</Y>
				<Z>0.349999994</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">StamperTool</string>
			<Content name="TextureId"><url>http://www.roblox.com/asset/?id=59102781</url></Content>
		</Properties>
		<Item class="Part" referent="RBX1">
			<Properties>
				<bool name="Anchored">false</bool>
				<bool name="Archivable">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>165.098831</X>
					<Y>0.274171323</Y>
					<Z>-445.195801</Z>
					<R00>0.995120585</R00>
					<R01>-7.11792454e-005</R01>
					<R02>0.0986662284</R02>
					<R10>-1.0218595e-005</R10>
					<R11>0.999999642</R11>
					<R12>0.000824476127</R12>
					<R20>-0.0986662582</R20>
					<R21>-0.000821461435</R21>
					<R22>0.995120227</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<token name="FormFactor">2</token>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>1</X>
					<Y>1</Y>
					<Z>1</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>1</X>
					<Y>0.400000006</Y>
					<Z>1</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX2">
				<Properties>
					<bool name="Archivable">true</bool>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>http://www.roblox.com/asset/?id=42163552</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>0.899999976</X>
						<Y>0.899999976</Y>
						<Z>0.899999976</Z>
					</Vector3>
					<Content name="TextureId"><url>http://www.roblox.com/asset/?id=42163513</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="ObjectValue" referent="RBX3">
			<Properties>
				<bool name="Archivable">true</bool>
				<string name="Name">PlayerOwner</string>
				<Ref name="Value">null</Ref>
			</Properties>
		</Item>
		<Item class="ObjectValue" referent="RBX4">
			<Properties>
				<bool name="Archivable">true</bool>
				<string name="Name">SavedState</string>
				<Ref name="Value">null</Ref>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX5">
			<Properties>
				<bool name="Archivable">true</bool>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">LuaGlobalVariables</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="BoolValue" referent="RBX6">
				<Properties>
					<bool name="Archivable">true</bool>
					<string name="Name">IsRestricted</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX7">
				<Properties>
					<bool name="Archivable">true</bool>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">InsertAsset</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="StringValue" referent="RBX8">
					<Properties>
						<bool name="Archivable">true</bool>
						<string name="Name">AssetName</string>
						<string name="Value"></string>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX9">
					<Properties>
						<bool name="Archivable">true</bool>
						<string name="Name">AssetId</string>
						<int name="Value">0</int>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX10">
					<Properties>
						<bool name="Archivable">true</bool>
						<string name="Name">Image</string>
						<string name="Value"></string>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX11">
					<Properties>
						<bool name="Archivable">true</bool>
						<string name="Name">StampMode</string>
						<bool name="Value">true</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX12">
					<Properties>
						<bool name="Archivable">true</bool>
						<string name="Name">Updated</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="BoolValue" referent="RBX13">
				<Properties>
					<bool name="Archivable">true</bool>
					<string name="Name">SwitchLoaderToDialog</string>
					<bool name="Value">false</bool>
				</Properties>
				<Item class="StringValue" referent="RBX14">
					<Properties>
						<bool name="Archivable">true</bool>
						<string name="Name">DialogType</string>
						<string name="Value">Stamp</string>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX15">
					<Properties>
						<bool name="Archivable">true</bool>
						<string name="Name">AssetImage</string>
						<string name="Value">nil</string>
					</Properties>
				</Item>
			</Item>
			<Item class="BoolValue" referent="RBX16">
				<Properties>
					<bool name="Archivable">true</bool>
					<string name="Name">ShowInvalidPlacement</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX17">
				<Properties>
					<bool name="Archivable">true</bool>
					<string name="Name">ShowMaxedOut</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX18">
				<Properties>
					<bool name="Archivable">true</bool>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">userID_readme</string>
					<ProtectedString name="Source">-- UsabilityMan: 11744447  (Production)
-- UsabilityMan: 7502714   (GameTest)</ProtectedString>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX19">
				<Properties>
					<bool name="Archivable">true</bool>
					<string name="Name">SwitchMode</string>
					<bool name="Value">false</bool>
				</Properties>
				<Item class="StringValue" referent="RBX20">
					<Properties>
						<bool name="Archivable">true</bool>
						<string name="Name">Mode</string>
						<string name="Value"></string>
					</Properties>
				</Item>
			</Item>
			<Item class="BoolValue" referent="RBX21">
				<Properties>
					<bool name="Archivable">true</bool>
					<string name="Name">Stamped</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX22">
				<Properties>
					<bool name="Archivable">true</bool>
					<string name="Name">Moving</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX23">
				<Properties>
					<bool name="Archivable">true</bool>
					<string name="Name">ShowAdminCategories</string>
					<bool name="Value">true</bool>
				</Properties>
			</Item>
			<Item class="IntValue" referent="RBX24">
				<Properties>
					<bool name="Archivable">true</bool>
					<string name="Name">userIDs</string>
					<int name="Value">6</int>
				</Properties>
				<Item class="IntValue" referent="RBX25">
					<Properties>
						<bool name="Archivable">true</bool>
						<string name="Name">userID</string>
						<int name="Value">11744447</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX26">
					<Properties>
						<bool name="Archivable">true</bool>
						<string name="Name">userID</string>
						<int name="Value">28215009</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX27">
					<Properties>
						<bool name="Archivable">true</bool>
						<string name="Name">userID</string>
						<int name="Value">28215010</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX28">
					<Properties>
						<bool name="Archivable">true</bool>
						<string name="Name">userID</string>
						<int name="Value">28215011</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX29">
					<Properties>
						<bool name="Archivable">true</bool>
						<string name="Name">userID</string>
						<int name="Value">28215012</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX30">
					<Properties>
						<bool name="Archivable">true</bool>
						<string name="Name">userID</string>
						<int name="Value">28215013</int>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX31">
			<Properties>
				<bool name="Archivable">true</bool>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">BasePlateGuide</string>
				<ProtectedString name="Source">local pointDirection = nil

local tailLength = 2 -- 2 or 7
--local dSize = -.05  -- .01 or .005
local dSize = 0 -- because we want the targets to all be the same size (tail isn&apos;t larger anymore; just &quot;ghost&quot; effect)
local dTime = .04 --.025

-- old targetLock pic (square): 48972746

local targetLockSize = .2
local arrowSize = .1

local arrowScreenProportionSize = .95
local arrowMoveFactor = .025

local targetMoveFactor = targetLockSize / 2 - .025

local halfDSize = dSize / 2

local r = game:service(&quot;RunService&quot;)

local vChar = script.Parent
if vChar == nil then script.Parent = nil end

local vPlay = game.Players:GetPlayerFromCharacter(vChar)
if vPlay == nil then script.Parent = nil end

local arrowGui = vPlay.PlayerGui:FindFirstChild(&quot;GuideArrowGui&quot;)
if arrowGui == nil then
	arrowGui = script.GuideArrowGui
	arrowGui.Parent = vPlay.PlayerGui
else
	script.GuideArrowGui:remove()
end

local upArrow = arrowGui.UpArrow
local downArrow = arrowGui.DownArrow
local leftArrow = arrowGui.LeftArrow
local rightArrow = arrowGui.RightArrow
local targetLock = arrowGui.TargetLock
local arrowList = {upArrow, downArrow, leftArrow, rightArrow, targetLock}

local goAway = arrowGui.GoAwayButton
goAway.Visible = true
goAway.Active = true
local keepShowing = true
goAway.MouseButton1Click:connect(function () keepShowing = false end)


local arrowHeightAugment = 0.0
local arrowWidthAugment = 0.0
local targetHeightAugment = 0.0
local targetWidthAugment = 0.0


local targetLockList = {targetLock}
for i = 1, tailLength do table.insert(targetLockList, targetLock:Clone()) end

targetLockList[1].Size = UDim2.new(targetLockSize, 0, targetLockSize, 0)
for i = 1, #targetLockList-1 do
	targetLockList[i+1].Parent = arrowGui
	--targetLockList[i+1].Size = UDim2.new(targetLockSize-i*dSize, 0, targetLockSize-i*dSize, 0)
end
-- switching over to a &quot;ghost-like&quot; transparency effect, but this means we have to upload separate images :(
-- if our tail is turned on, manually apply the ghosting to the next two images
if tailLength &gt; 0 then targetLockList[2].Image = &quot;http://www.roblox.com/asset/?id=49324811&quot; end
if tailLength &gt; 1 then targetLockList[3].Image = &quot;http://www.roblox.com/asset/?id=49324846&quot; end


function onResize() -- force arrows into a square resolution
	xSize = arrowGui.AbsoluteSize.X
	ySize = arrowGui.AbsoluteSize.Y

	if xSize &gt;= ySize then
		arrowHeightAugment = 0.0

		-- calculate arrowWidthAugment and new arrow ratio here
		newArrowUDim = UDim2.new(ySize / xSize * arrowSize, 0, arrowSize, 0)
		rightArrow.Size = newArrowUDim 
		leftArrow.Size = newArrowUDim 
		upArrow.Size = newArrowUDim 
		downArrow.Size = newArrowUDim

		for tli = 1, #targetLockList do
			targetLockList[tli].Size = UDim2.new(ySize / xSize * (targetLockSize-tli*dSize), 0, targetLockSize-tli*dSize, 0)
		end

		arrowWidthAugment = (xSize - ySize)*arrowSize*.5 / xSize
	else
		arrowWidthAugment = 0.0

		-- calculate arrowHeightAugment here
		newArrowUDim = UDim2.new(arrowSize, 0, xSize / ySize * arrowSize, 0)
		rightArrow.Size = newArrowUDim
		leftArrow.Size = newArrowUDim
		upArrow.Size = newArrowUDim
		downArrow.Size = newArrowUDim

		for tli = 1, #targetLockList do
			targetLockList[tli].Size = UDim2.new(targetLockSize-tli*dSize, 0, xSize / ySize * (targetLockSize-tli*dSize), 0)
		end

		arrowHeightAugment = (ySize - xSize)*arrowSize*.5 / ySize
	end

	targetWidthAugment = targetLock.Size.X.Scale / 2 - .025
	targetHeightAugment = targetLock.Size.Y.Scale / 2 - .025
end

arrowGui.Changed:connect(onResize) -- dynamically resize the arrows on screen resize

function findMyBasePlate()
	--if true then return game.Workspace.Base end -- for testing purposes

	local buildingAreas = game.Workspace.BuildingAreas:GetChildren()
	for i = 1, #buildingAreas do
		if buildingAreas[i].Player.Value == script.Parent.Name then
			return buildingAreas[i]:FindFirstChild(&quot;BasePlate&quot;) or buildingAreas[i].PlayerArea:FindFirstChild(&quot;BasePlate&quot;)
		end
	end
end

local myBase = findMyBasePlate()
if myBase == nil then
	print(&quot;BasePlateGuide script error: no base plate found!&quot;)
	-- abort if no BasePlate found
	arrowGui:remove()
	script:remove()
end

function setVisible(whichArrow)
	for i = 1, #arrowList do
		if arrowList[i] == whichArrow then
			arrowList[i].Visible = true
		else
			arrowList[i].Visible = false
		end
	end
end

function truncate(number, augmentation)
	if number+augmentation &lt; 0 then return 0 
   elseif number &gt; (1 - arrowSize)+augmentation then return (1 - arrowSize)+2*augmentation -- furthest extent we want the arrows to reach is .95 - arrowSize
	else return number+augmentation end
end


function notInBasePlate(myPos, base)
	local corner1 = base.Position - base.Size/2
	local corner2 = base.Position + base.Size/2
	if myPos.X &gt; corner1.X and myPos.Y &gt; corner1.Y and myPos.Z &gt; corner1.Z and myPos.X &lt; corner2.X and myPos.Z &lt; corner2.Z then -- we only care they&apos;re somewhere above baseplate
		return false
	else
		return true
	end
end

local lastTime = 0
local camera = game.Workspace.CurrentCamera
while notInBasePlate(script.Parent.Torso.Position, myBase) and keepShowing do
	--pointDirection = (myBase.Position - script.Parent.Torso.Position) * Vector3.new(1, 0, 1)
	camFrame = camera.CoordinateFrame
	pointDirection = camFrame:vectorToObjectSpace(myBase.Position - camFrame.p)
	camZ = pointDirection.Z
	camX = pointDirection.X/math.abs(camZ)
	camY = pointDirection.Y/math.abs(camZ)
	--print(camX, camY, camZ)

	-- was .55 for 610 (Y) and 1.15 for 1286 (X), so seems like scaling factor is universally 1114 on both axes	
	-- nvm:  at 1662 x 666, we have ... and .55, so seems like .55 always for Y, then X is scaled according to its proportion to Y

	local xThreshold = arrowGui.AbsoluteSize.X / arrowGui.AbsoluteSize.Y * .55
	local yThreshold = .55

	local nCamX = camX / xThreshold
	local nCamY = camY / yThreshold

	if (math.abs(nCamX) &gt; 1 or math.abs(nCamY) &gt; 1) or (camZ &gt; 0) then -- camZ test makes sure we only lock on if facing right direction
		for j = 2, #targetLockList do
			targetLockList[j].Visible = false
		end
	
		if math.abs(nCamX) &gt; math.abs(nCamY) then
			--if nCamY &gt; 1 then nCamY = 1
			--elseif nCamY &lt; -1 then nCamY = -1 end

			if camX &gt; 0 then
				-- should go right
				rightArrow.Position = UDim2.new(arrowScreenProportionSize - arrowMoveFactor - .025 + 2*arrowWidthAugment, 0, truncate(arrowScreenProportionSize*(1-nCamY)/2 - arrowMoveFactor, arrowHeightAugment), 0)
				setVisible(rightArrow)
			else
				-- should go left
				leftArrow.Position = UDim2.new(0, 0, truncate(arrowScreenProportionSize*(1-nCamY)/2 - arrowMoveFactor, arrowHeightAugment), 0)
				setVisible(leftArrow)
			end
		else
			--if nCamX &gt; 1 then nCamX = 1
			--elseif nCamX &lt; -1 then nCamX = -1 end

			if camY &gt; 0 then
				-- should go up
				upArrow.Position = UDim2.new(truncate(arrowScreenProportionSize*(nCamX+1)/2 - arrowMoveFactor, arrowWidthAugment), 0, 0, 0)
				setVisible(upArrow)
			else
				-- should go down
				downArrow.Position = UDim2.new(truncate(arrowScreenProportionSize*(nCamX+1)/2 - arrowMoveFactor, arrowWidthAugment), 0, arrowScreenProportionSize - arrowMoveFactor -.025 + 2*arrowHeightAugment, 0)
				setVisible(downArrow)
			end
		end
	else
		-- locked on target
		--for j = 2, #targetLockList do
			--targetLockList[j].Visible = true
		--end
		--targetLock.Position = UDim2.new(.95*(nCamX+1)/2 - targetMoveFactor, 0, .95*(1-nCamY)/2 - targetMoveFactor, 0)
		targetLock.Position = UDim2.new(.95*(nCamX+1)/2 - targetWidthAugment, 0, .95*(1-nCamY)/2 - targetHeightAugment, 0)
		setVisible(targetLock)
	end

	--wait()
	
	-- update every dTime seconds

	-- ok to do it this way instead of a ring array, because even though it&apos;s less efficient, it&apos;s less efficient by only one or two commands [since only have 2 &quot;tails&quot;]

	local t = r.Stepped:wait()
	if t - lastTime &gt; dTime then
		lastTime = t
		for j = #targetLockList, 2, -1 do
			targetLockList[j].Position = targetLockList[j-1].Position + UDim2.new(halfDSize, 0, halfDSize, 0)
			targetLockList[j].Visible = targetLockList[j-1].Visible
		end
	end
end

--[[setVisible(nil)
for j = 2, #targetLockList do
	targetLockList[j].Visible = false
end
goAway.Visible = false
goAway.Active = false
]]--
arrowGui:remove()
script:remove()</ProtectedString>
			</Properties>
			<Item class="ScreenGui" referent="RBX32">
				<Properties>
					<bool name="Archivable">true</bool>
					<string name="Name">GuideArrowGui</string>
				</Properties>
				<Item class="ImageLabel" referent="RBX33">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="Archivable">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=48972729 </url></Content>
						<string name="Name">UpArrow</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.0500000007</XS>
							<XO>0</XO>
							<YS>0.0500000007</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX34">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="Archivable">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=48972703</url></Content>
						<string name="Name">RightArrow</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.0500000007</XS>
							<XO>0</XO>
							<YS>0.0500000007</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX35">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="Archivable">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=48972653</url></Content>
						<string name="Name">DownArrow</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.0500000007</XS>
							<XO>0</XO>
							<YS>0.0500000007</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX36">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="Archivable">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=48972682</url></Content>
						<string name="Name">LeftArrow</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.0500000007</XS>
							<XO>0</XO>
							<YS>0.0500000007</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX37">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="Archivable">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>http://www.roblox.com/asset/?id=49321779</url></Content>
						<string name="Name">TargetLock</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.0500000007</XS>
							<XO>0</XO>
							<YS>0.0500000007</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX38">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="Archivable">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4278255360</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">0</token>
						<string name="Name">GoAwayButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>20</XO>
							<YS>0</YS>
							<YO>40</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>150</XO>
							<YS>0</YS>
							<YO>20</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text">Hide Guide Arrows</string>
						<Color3 name="TextColor3">4279970357</Color3>
						<float name="TextTransparency">0</float>
						<bool name="TextWrap">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX39">
			<Properties>
				<bool name="Archivable">true</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">StampScript</string>
				<ProtectedString name="Source">-- basic functions

function waitForChild(instance, name)
	while not instance:findFirstChild(name) do
		instance.ChildAdded:wait()
	end
end
----------------------------------------------------------------------------------------

-- Locals

local Tool = script.Parent

local Mouse
local mouseMoveCon
local mouseButton1DownCon
local mouseButton1UpCon

local pressedEsc = false

local gInitial90DegreeRotations = 0
local gStaticTrans = 0.7

local useAssetVersionId = true

waitForChild(Tool,&quot;LuaGlobalVariables&quot;)
local variables = Tool.LuaGlobalVariables
waitForChild(variables,&quot;ShowInvalidPlacement&quot;)
waitForChild(variables, &quot;Stamped&quot;)
waitForChild(Tool,&quot;ErrorBox&quot;)
local errorBox = Tool.ErrorBox

local Data = {}
Data.Stamp = {}
Data.Loading = {}

local eyeDropperConnection, eyeDropperMoveConnection--[[, deleteMoveConnection, deleteButtonDownConnection]]

local playerModel
local player

-- For Restricting Stamper Tool
local isRestricted = variables.IsRestricted.Value

-- For Delete highlighting
local selectionBox
local currentSelection
local currentSelectionColors = {}

if isRestricted then waitForChild(game.Workspace, &quot;BaseplateBumpers&quot;) end
----------------------------------------------------------------------------------------


-- Functions
local manualWeldTable = {}
local manualWeldParentTable = {}
function saveTheWelds(object)
	if object:IsA(&quot;ManualWeld&quot;) then
		table.insert(manualWeldTable, object)
		table.insert(manualWeldParentTable, object.Parent)
	else
		local children = object:GetChildren()
		for i = 1, #children do
			saveTheWelds(children[i])
		end
	end
end

function restoreTheWelds()
	for i = 1, #manualWeldTable do
		manualWeldTable[i].Parent = manualWeldParentTable[i]
	end
end


function findSeatsInModel(parent, seatTable)
	if not parent then return end

	if parent.className == &quot;Seat&quot; or parent.className == &quot;VehicleSeat&quot; then
		table.insert(seatTable, parent)
	end
	local myChildren = parent:GetChildren()
	for j = 1, #myChildren do
		findSeatsInModel(myChildren[j], seatTable)
	end
end

function setSeatEnabledStatus(model, isEnabled)
	local seatList = {}
	findSeatsInModel(model, seatList)

	if isEnabled then
		-- remove any welds called &quot;SeatWeld&quot; in seats
		for i = 1, #seatList do
			local nextSeat = seatList[i]:FindFirstChild(&quot;SeatWeld&quot;)
			while nextSeat do nextSeat:Remove() nextSeat = seatList[i]:FindFirstChild(&quot;SeatWeld&quot;) end
		end
	else
		-- put a weld called &quot;SeatWeld&quot; in every seat
		--   this tricks it into thinking there&apos;s already someone sitting there, and it won&apos;t make you sit XD
		for i = 1, #seatList do
			local fakeWeld = Instance.new(&quot;Weld&quot;)
			fakeWeld.Name = &quot;SeatWeld&quot;
			fakeWeld.Parent = seatList[i]
		end
	end
end


function UnlockInstances(object)

	if object:IsA(&quot;BasePart&quot;) then
		object.Locked = false
	end
	for index,child in pairs(object:GetChildren()) do
		UnlockInstances(child)
	end

end


function getPlayer()
	return game.Players:GetPlayerFromCharacter(script.Parent.Parent)
end


function beginInsertDecal(decal)

	Data.Stamp.DecalSelection = Instance.new(&quot;SurfaceSelection&quot;)
	Data.Stamp.DecalSelection.Color = BrickColor.new(&quot;Bright orange&quot;)
	Data.Stamp.DecalSelection.archivable = false
	Data.Stamp.DecalSelection.Parent = getPlayer().PlayerGui

	--Save the decal in our Lua code for later use
	Data.Stamp.Decal = decal
	Data.Stamp.Decal.Parent = nil

end


-- signal to gui to switch frames
function signalInsertComplete(type)

	if type == &quot;SideDialog&quot; then
		variables.SwitchLoaderToDialog.DialogType.Value = &quot;SideDialog&quot;
		variables.SwitchLoaderToDialog.Value = true
	elseif type == &quot;Main&quot; then
		variables.SwitchLoaderToDialog.DialogType.Value = &quot;Main&quot;
		variables.SwitchLoaderToDialog.Value = true
	elseif type == &quot;EyeDropper&quot; then
		variables.SwitchLoaderToDialog.DialogType.Value = &quot;EyeDropper&quot;
		variables.SwitchLoaderToDialog.Value = true
	end

	-- needed to make sure we disconnect eyedroper handler
	if type ~= &quot;EyeDropper&quot; then
		if eyeDropperConnection then eyeDropperConnection:disconnect() end
		if eyeDropperMoveConnection then eyeDropperMoveConnection:disconnect() end
	end
	clearSelection()

end


function beginInsertAssetStamp(assetName, assetId, image, stampMode)
	-- trying to stop assets, gone back to Main Stamp Dialog
	if assetId == 0 then
		cancelAssetPlacement()
		return
	end

	-- This call will cause a &quot;wait&quot; until the data comes back
	-- below we wait a max of 8 seconds before deciding to bail out on loading
	local root
	local loader
	loading = true
	if useAssetVersionId then
		loader = coroutine.create(function()	
			root = game:GetService(&quot;InsertService&quot;):LoadAssetVersion(assetId)
			loading = false
		end)
		coroutine.resume(loader)
	else
		loader = coroutine.create(function()	
			root = game:GetService(&quot;InsertService&quot;):LoadAsset(assetId)
			loading = false
		end)
		coroutine.resume(loader)
	end

	local lastGameTime = 0
	local totalTime = 0
	local maxWait = 8
	while loading and totalTime &lt; maxWait do
		lastGameTime = tick()
		wait(1)
		totalTime = totalTime + tick() - lastGameTime
	end
	loading = false

	if totalTime &gt;= maxWait or pressedEsc then
		Data.Loading.Cancelled = true
		pressedEsc = false
	else
		Data.Loading.Cancelled = false
	end


	if Data.Loading.Cancelled then
		--The user got bored and wandered off
		--Just delete the model from the world... a shame we loaded it when they got bored
		-- 12/28/2010: Putting this inside a pcall (on gametest, first time equipping stamper, this was being called with root=nil.) (Jahr)
		pcall(function() root:Remove() end)
		signalInsertComplete(&quot;Main&quot;)
	else
		local instances = root:GetChildren()
		if #instances == 0 then
			root:Remove()
			signalInsertComplete(&quot;Main&quot;)
			return
		end

		--Unlock all parts that are inserted, to make sure they are editable
		UnlockInstances(root)

		--Continue the insert process
		root.Name = &quot;InsertedObject&quot; .. assetId

		--Examine the contents and decide what it looks like
		for pos, instance in pairs(instances) do
			--Single instance objects might be treated special, decals/skyboxes
			if instance:IsA(&quot;Decal&quot;) then
				--Current system here stops after finding one Decal (and gives you Decal tool)
				--We should do the same (probably)
				beginInsertDecal(instance)
				root:Remove()

				Window.Stamp.Frame.Visible = true
				return
			elseif instance:IsA(&quot;Team&quot;) then
				instance.Parent = game:GetService(&quot;Teams&quot;)
			elseif instance:IsA(&quot;SpawnLocation&quot;) then
				-- uh.............
			elseif instance:IsA(&quot;HopperBin&quot;) then
				-- Must go into the starterPack, prompt user?
			elseif instance:IsA(&quot;Tool&quot;) then
				-- Ask them if it should go in StarterPack?
			elseif instance:IsA(&quot;Sky&quot;) then
				local lightingService = game:GetService(&quot;Lighting&quot;)
				for index,child in pairs(lightingService:GetChildren()) do
					if child:IsA(&quot;Sky&quot;) then
						child:Remove();
					end
				end
				instance.Parent = lightingService
				return
			else

			end
		end

		if #root:GetChildren() == 0 then
			root:Remove()
			signalInsertComplete(&quot;Main&quot;)
			return
		end

		signalInsertComplete(&quot;SideDialog&quot;)
		
		cancelAssetPlacement()
		Data.Stamp.Model = root
		setupDraggableClone()
	end

end


function positionPartsAtCFrame3(partOrModel, aCFrame)

	local insertCFrame
	if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
		--insertCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[1].CFrame
		-- we assume model has at least one part in it; need to find first part
		i = 1
		while (i &lt; (#Data.Stamp.CurrentParts[1]:GetChildren()) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;Part&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;TrussPart&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;WedgePart&quot;)) do
			i = i + 1
		end
		insertCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[i].CFrame

		for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
			if object:IsA(&quot;Flag&quot;) then object = object.Handle end
			if (object:IsA(&quot;Part&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;Seat&quot;) or object:IsA(&quot;VehicleSeat&quot;)) then
				local posPartInWorld = object.Position
				local posPart1InWorld = insertCFrame.p
				local newPosPartInWorld = posPartInWorld - posPart1InWorld + aCFrame.p
	
				local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = object.CFrame:components()
				object.CFrame = CFrame.new(newPosPartInWorld.x, newPosPartInWorld.y, newPosPartInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
			end
		end
		else
		Data.Stamp.CurrentParts[1].CFrame = aCFrame
	end

end


-- For Restricting Stamper Tool (isRestricted)
function inBounds(object)

	for part, transparency in pairs(object) do
		if part:IsA(&quot;Part&quot;) or part:IsA(&quot;WedgePart&quot;) or part:IsA(&quot;TrussPart&quot;) then
			if not partInBounds(part) then return false end
		elseif part:IsA(&quot;Model&quot;) then
			local primPart = object.PrimaryPart
			if not partInBounds(primPart) then return false end
		end
	end
	return true

end

function partInBounds(part)

	if part == nil then return false end

	local xOne= buildingPlate.Position.x + buildingPlate.Size.x/2
	local xTwo = buildingPlate.Position.x - buildingPlate.Size.x/2
	local zOne = buildingPlate.Position.z + buildingPlate.Size.z/2
	local zTwo = buildingPlate.Position.z - buildingPlate.Size.z/2

	if part.Position.x &gt; xOne or part.Position.x &lt; xTwo then return false end
	if part.Position.z &gt; zOne or part.Position.z &lt; zTwo then return false end

	return true

end



function canSelectObject(part)
	return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end

function canEyeDropperObject(part)
	local stamperTag = part.Parent:FindFirstChild(&quot;RobloxStamper&quot;)
	if stamperTag == nil then stamperTag = part:FindFirstChild(&quot;RobloxStamper&quot;) end

	return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60 and stamperTag ~= nil
end

--[[
function canDeleteObject(part)
	-- let them delete anything that they created *or* anything on their baseplate
	return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60 and (isChildOfMyModel(part) or partInBounds(part))
end]]

function onInsertMouseMove()

	if Data.Stamp.MovingLock then
		return
	end

	if isRestricted then
		Mouse.TargetFilter = game.Workspace.BaseplateBumpers
	end

	Data.Stamp.MovingLock = true
	if Data.Stamp.Dragger == nil then
		if Data.Stamp.Model ~= nil then
			if isRestricted then
				if checkPartLimit() then
					setupDraggableClone()
				else
					variables.ShowMaxedOut.Value = true
				end
			else
				setupDraggableClone()
			end
		end
	else
		-- REM TL: Data.Stamp.Dragger:MouseMove(Mouse.UnitRay)
		-- don&apos;t move with dragger - will move in one step on mouse down
		-- draw ghost at acceptable positions
		configFound, targetCFrame = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)
		if configFound then
			positionPartsAtCFrame3(Data.Stamp.CurrentParts[1], targetCFrame)
		end
		-- to show joints during the mouse move
      game.JointsService:SetJoinAfterMoveInstance(Data.Stamp.CurrentParts[1])
      if Mouse.Target and Mouse.Target.Parent:FindFirstChild(&quot;RobloxModel&quot;) == nil then
			game.JointsService:SetJoinAfterMoveTarget(Mouse.Target)
      else
			game.JointsService:SetJoinAfterMoveTarget(nil)
      end
      game.JointsService:ShowPermissibleJoints()
	end

	Data.Stamp.MovingLock = false

end


function onInsertMouseButton1Down()

	if Data.Stamp.Dragger or Data.Stamp.Decal then
		Data.Stamp.MouseDown = true
	end

end


function cancelAssetPlacement()

	gInitial90DegreeRotations = 0
	Data.Stamp.Cancelled = true
	Data.Stamp.Dragger = nil
	if Data.Stamp.Model then
		Data.Stamp.Model:Remove()
		Data.Stamp.Model = nil
	end
	if Data.Stamp.CurrentParts then
		for index, object in pairs(Data.Stamp.CurrentParts) do
			object:Remove()
		end
	
		Data.Stamp.CurrentParts.Parent = nil
		Data.Stamp.CurrentParts = nil
	end

	if Data.Stamp.DecalSelection then
		Data.Stamp.DecalSelection:Remove()
		Data.Stamp.DecalSelection = nil
	end
	if Data.Stamp.Decal then
		Data.Stamp.Decal:Remove()
		Data.Stamp.Decal = nil
	end

	if Mouse then
		Mouse.Icon =&quot;rbxasset://textures\\ArrowCursor.png&quot;
	end
	game.JointsService:ClearJoinAfterMoveJoints()

end


function collectParts(object, baseParts, scripts, decals)

	if object:IsA(&quot;BasePart&quot;) then
		baseParts[#baseParts+1] = object
	elseif object:IsA(&quot;Script&quot;) then
		scripts[#scripts+1] = object
	elseif object:IsA(&quot;Decal&quot;) then
		decals[#decals+1] = object
	end

	for index,child in pairs(object:GetChildren()) do
		collectParts(child, baseParts, scripts, decals)
	end

end

function getTargetPartBoundingBox(targetPart)

	if targetPart.Parent:FindFirstChild(&quot;RobloxModel&quot;) ~= nil then
		return getBoundingBox2(targetPart.Parent)
	else
		return getBoundingBox2(targetPart)
	end

end


function getBoundingBox2(partOrModel)

-- for models, the bounding box is defined as the minimum and maximum individual part bounding boxes
-- relative to the first part&apos;s coordinate frame.

	local minVec = Vector3.new(math.huge, math.huge, math.huge)
	local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

	if partOrModel:IsA(&quot;Part&quot;) or partOrModel:IsA(&quot;WedgePart&quot;) or partOrModel:IsA(&quot;TrussPart&quot;)then
		minVec = -0.5 * partOrModel.Size
		maxVec = -minVec
	else
		local part1 = partOrModel:GetChildren()[1]
		if partOrModel:IsA(&quot;Tool&quot;) then part1 = partOrModel.Handle if not part1 then return end end
		if part1:IsA(&quot;Flag&quot;) then part1 = partOrModel:FindFirstChild(&quot;Part&quot;) if not part1 then return end end
		for i, object in pairs(partOrModel:GetChildren()) do
			if (object:IsA(&quot;Part&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;TrussPart&quot;)) then
				boxMinInWorld = object.CFrame:pointToWorldSpace(-0.5 * object.Size)
				boxMinInPart1 = part1.CFrame:pointToObjectSpace(boxMinInWorld)
				boxMaxInWorld = object.CFrame:pointToWorldSpace(0.5 * object.Size)
				boxMaxInPart1 = part1.CFrame:pointToObjectSpace(boxMaxInWorld)

				local minX = minVec.x
				local minY = minVec.y
				local minZ = minVec.z
				local maxX = maxVec.x
				local maxY = maxVec.y
				local maxZ = maxVec.z
				if boxMinInPart1.x &lt; minVec.x then
					minX = boxMinInPart1.x
				end
				if boxMinInPart1.y &lt; minVec.y then
					minY = boxMinInPart1.y
				end
				if boxMinInPart1.z &lt; minVec.z then
					minZ = boxMinInPart1.z
				end
				if boxMaxInPart1.x &lt; minX then
					minX = boxMaxInPart1.x
				end
				if boxMaxInPart1.y &lt; minY then
					minY = boxMaxInPart1.y
				end
				if boxMaxInPart1.z &lt; minZ then
					minZ = boxMaxInPart1.z
				end

				if boxMinInPart1.x &gt; maxVec.x then
					maxX = boxMinInPart1.x
				end
				if boxMinInPart1.y &gt; maxVec.y then
					maxY = boxMinInPart1.y
				end
				if boxMinInPart1.z &gt; maxVec.z then
					maxZ = boxMinInPart1.z
				end
				if boxMaxInPart1.x &gt; maxX then
					maxX = boxMaxInPart1.x
				end
				if boxMaxInPart1.y &gt; maxY then
					maxY = boxMaxInPart1.y
				end
				if boxMaxInPart1.z &gt; maxZ then
					maxZ = boxMaxInPart1.z
				end

				minVec = Vector3.new(minX, minY, minZ)
				maxVec = Vector3.new(maxX, maxY, maxZ)
			end
		end
	end

	-- Adjust bounding box to reflect what the model or part author wants in  terms of justification
	local justifyValue = partOrModel:FindFirstChild(&quot;Justification&quot;)
	if justifyValue ~= nil then
		-- find the multiple of 4 that contains the model
		justify = justifyValue.Value
		two = Vector3.new(2, 2, 2)
		actualBox = maxVec - minVec - Vector3.new(0.01, 0.01, 0.01)
		containingGridBox = Vector3.new(4 * math.ceil(actualBox.x/4), 4 * math.ceil(actualBox.y/4), 4 * math.ceil(actualBox.z/4))
		adjustment = containingGridBox - actualBox
		minVec = minVec - 0.5 * adjustment * justify
		maxVec = maxVec + 0.5 * adjustment * (two - justify)
	end

	return minVec, maxVec

end


function getClosestAlignedWorldDirection(aVector3InWorld)

	local xDir = Vector3.new(1,0,0)
	local yDir = Vector3.new(0,1,0)
	local zDir = Vector3.new(0,0,1)
	local xDot = aVector3InWorld.x * xDir.x + aVector3InWorld.y * xDir.y + aVector3InWorld.z * xDir.z
	local yDot = aVector3InWorld.x * yDir.x + aVector3InWorld.y * yDir.y + aVector3InWorld.z * yDir.z
	local zDot = aVector3InWorld.x * zDir.x + aVector3InWorld.y * zDir.y + aVector3InWorld.z * zDir.z

	if math.abs(xDot) &gt; math.abs(yDot) and math.abs(xDot) &gt; math.abs(zDot) then
		if xDot &gt; 0 then
			return 0
		else
			return 3
		end
	elseif math.abs(yDot) &gt; math.abs(xDot) and math.abs(yDot) &gt; math.abs(zDot) then
		if yDot &gt; 0 then
			return 1
		else
			return 4
		end
	else
		if zDot &gt; 0 then
			return 2
		else
			return 5
		end
	end 

end


function getMouseTargetCFrame(targetPart)

	if targetPart.Parent:FindFirstChild(&quot;RobloxModel&quot;) ~= nil then
		if targetPart.Parent:IsA(&quot;Tool&quot;) then return targetPart.Parent.Handle.CFrame
		else return targetPart.Parent:GetChildren()[1].CFrame end
	else
		return targetPart.CFrame
	end

end


function findConfigAtMouseTarget(partsTable)

-- *Critical Assumption* :
--				This function assumes the target CF axes are orthogonal with the target bounding box faces
--				And, it assumes the insert CF axes are orthongonal with the insert bounding box faces
--				Therefore, insertion will not work with angled faces on wedges or other &quot;non-block&quot; parts, nor
--				will it work for parts in a model that are not orthogonally aligned with the model&apos;s CF.

	local grid = 4.0
	local admissibleConfig = false
	local targetConfig = CFrame.new(0,0,0)

	local minBB, maxBB = getBoundingBox2(Data.Stamp.CurrentParts[1])
	local diagBB = maxBB - minBB

	local insertCFrame
	if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
		i = 1
		while (i &lt; (#Data.Stamp.CurrentParts[1]:GetChildren()) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;Part&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;TrussPart&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;WedgePart&quot;)) do
			i = i + 1
		end
		insertCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[i].CFrame
	else
		insertCFrame = Data.Stamp.CurrentParts[1].CFrame
	end

	if not isRestricted then
		if Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then Mouse.TargetFilter = Data.Stamp.CurrentParts[1].Handle
		else Mouse.TargetFilter = Data.Stamp.CurrentParts[1] end
	end

	local targetPart = Mouse.Target

	if targetPart == nil then
		return admissibleConfig, targetConfig
	end

	-- test mouse hit location
	local minBBTarget, maxBBTarget = getTargetPartBoundingBox(targetPart)
	local diagBBTarget = maxBBTarget - minBBTarget
	local targetCFrame = getMouseTargetCFrame(targetPart)
	local hitCFrame = Mouse.Hit
	local mouseHitInWorld = hitCFrame.p
	local mouseHitInTarget = targetCFrame:pointToObjectSpace(mouseHitInWorld)

	-- find which axis of the insertion objects should match with the target surface
	-- this should use targetPart CFrame, not the model CFrame
	local targetVectorInWorld = targetPart.CFrame:vectorToWorldSpace(Vector3.FromNormalId(Mouse.TargetSurface))

	local targetRefPointInTarget
	local clampToSurface

	if getClosestAlignedWorldDirection(targetVectorInWorld) == 0 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		clampToSurface = Vector3.new(0,1,1)
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 3 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
		clampToSurface = Vector3.new(0,1,1)
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 1 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		clampToSurface = Vector3.new(1,0,1)		
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 4 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
		clampToSurface = Vector3.new(1,0,1)
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 2 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
		clampToSurface = Vector3.new(1,1,0)
	else
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
		clampToSurface = Vector3.new(1,1,0)
	end

	targetRefPointInTarget = targetRefPointInTarget * (0.5 * diagBBTarget) + 0.5 * (maxBBTarget + minBBTarget)
	insertRefPointInInsert = insertRefPointInInsert * (0.5 * diagBB) + 0.5 * (maxBB + minBB)
	
	-- To Do: For cases that are not aligned to the world grid, account for the minimal rotation
	-- needed to bring the Insert part(s) into alignment with the Target Part
	-- Apply the rotation here

	local delta = mouseHitInTarget - targetRefPointInTarget
	local deltaClamped = Vector3.new(grid * math.modf(delta.x/grid), grid * math.modf(delta.y/grid), grid * math.modf(delta.z/grid))
	deltaClamped = deltaClamped * clampToSurface
	local targetTouchInTarget = deltaClamped + targetRefPointInTarget

	local TargetTouchRelToWorld = targetCFrame:pointToWorldSpace(targetTouchInTarget)
	local InsertTouchInWorld = insertCFrame:vectorToWorldSpace(insertRefPointInInsert)
	local posInsertOriginInWorld = TargetTouchRelToWorld - InsertTouchInWorld

	local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = insertCFrame:components()
	targetConfig = CFrame.new(posInsertOriginInWorld.x, posInsertOriginInWorld.y, posInsertOriginInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
	admissibleConfig = true

	return admissibleConfig, targetConfig

end

function checkPartLimit()

	local numPoints = player.PointsUsed.Value
	local maxPoints = player.MaxPoints.Value

	if numPoints &lt; maxPoints then
		return true
	else
		return false
	end

	return true
end

function setupDraggableClone()

	--if not Mouse.Target then return end

	if Data.Stamp.CurrentParts then
		for i = 1, #Data.Stamp.CurrentParts do
			Data.Stamp.CurrentParts[i].Parent = partModel
		end
	end

	local clone = Data.Stamp.Model:Clone()
	local scripts = {}
	local parts = {}
	local decals = {}
	
	collectParts(clone, parts, scripts, decals)

	if #parts &gt; 0 then
		Data.Stamp.DisabledScripts = {}
		Data.Stamp.TransparencyTable = {}
		Data.Stamp.MaterialTable = {}
		Data.Stamp.CanCollideTable = {}
		Data.Stamp.AnchoredTable = {}
		Data.Stamp.DecalTransparencyTable = {}

		for index,script in pairs(scripts) do
			if not(script.Disabled) then
				script.Disabled = true
				Data.Stamp.DisabledScripts[#Data.Stamp.DisabledScripts +1] = script
			end
		end
		for index, part in pairs(parts) do
			Data.Stamp.TransparencyTable[part] = part.Transparency
			part.Transparency = gStaticTrans + (1-gStaticTrans)*part.Transparency
			Data.Stamp.MaterialTable[part] = part.Material
			part.Material = Enum.Material.Plastic
			Data.Stamp.CanCollideTable[part] = part.CanCollide
			part.CanCollide = false
			Data.Stamp.AnchoredTable[part] = part.Anchored
			part.Anchored = true
			part.archivable = false
		end

		for index, decal in pairs(decals) do
			Data.Stamp.DecalTransparencyTable[decal] = decal.Transparency
			decal.Transparency = gStaticTrans + (1-gStaticTrans)*decal.Transparency
		end

		game:GetService(&quot;InsertService&quot;):Insert(clone)

		-- For Restricting Stamper Tool
		if(isRestricted) then

			-- mark a particular spot in BaseplateBumpers, so we can remove any stragglers later, when player leaves
			local cloneInsertionSpot = game.Workspace.BaseplateBumpers:FindFirstChild(player.Name)
			if cloneInsertionSpot == nil then
				cloneInsertionSpot = Instance.new(&quot;Model&quot;)
				cloneInsertionSpot.Name = player.Name
				cloneInsertionSpot.Parent = game.Workspace.BaseplateBumpers
			end

			-- disable all seats
			setSeatEnabledStatus(clone, false)

			clone.Parent = cloneInsertionSpot
		end

		Data.Stamp.CurrentParts = clone:GetChildren()

		-- pre-rotate if necessary
		local ry = gInitial90DegreeRotations * math.pi/2
		local rotCF = CFrame.fromEulerAnglesXYZ(0, ry, 0) 
		if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
			for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
				if object:IsA(&quot;Flag&quot;) then object = object.Handle end
				if object:IsA(&quot;Part&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;Seat&quot;) or object:IsA(&quot;VehicleSeat&quot;) then object.CFrame = rotCF * object.CFrame end
			end
		else
			Data.Stamp.CurrentParts[1].CFrame = rotCF * Data.Stamp.CurrentParts[1].CFrame
		end

		-- After rotating, update the position
		configFound, targetCFrame = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)
		if configFound then
			positionPartsAtCFrame3(Data.Stamp.TransparencyTable, targetCFrame)
		end
		-- to show joints during the mouse move
      game.JointsService:SetJoinAfterMoveInstance(Data.Stamp.CurrentParts[1])
      if Mouse.Target and Mouse.Target.Parent:FindFirstChild(&quot;RobloxModel&quot;) == nil then
			game.JointsService:SetJoinAfterMoveTarget(Mouse.Target)
      else
			game.JointsService:SetJoinAfterMoveTarget(nil)
		end
      game.JointsService:ShowPermissibleJoints()

		for index, object in pairs(Data.Stamp.CurrentParts) do
			object.Parent = clone.Parent
		end
		clone:Remove()

		Data.Stamp.Dragger = Instance.new(&quot;Dragger&quot;)
		--Begin a movement by faking a MouseDown signal
		Data.Stamp.Dragger:MouseDown(parts[1], Vector3.new(0,0,0), parts)
		Data.Stamp.Dragger:MouseUp()
	else
		--Nothing draggable in the Model
		Data.Stamp.Model:Remove()
		Data.Stamp.Model = nil
		Data.Stamp.TransparencyTable = nil
		Data.Stamp.MaterialTable = nil
		Data.Stamp.CanCollideTable = nil
		Data.Stamp.AnchoredTable = nil
		Data.Stamp.DisabledScripts = nil
	end

end


function noManualWelds(part)
	local partChildren = part:GetChildren()
	for i = 1, #partChildren do
		if partChildren[i]:IsA(&quot;ManualWeld&quot;) then
			return false
		end
	end
	return true
end

local debris = game:GetService(&quot;Debris&quot;)
function flashRedBox()
	errorBox.Parent = player.PlayerGui
	if Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then errorBox.Adornee = Data.Stamp.CurrentParts[1].Handle
	else errorBox.Adornee = Data.Stamp.CurrentParts[1] end

	delay(0,function()
		for i = 1, 3 do
			errorBox.Visible = true
			wait(0.13)
			errorBox.Visible = false
			wait(0.13)
		end
		errorBox.Adornee = nil
		errorBox.Parent = Tool
	end)
end


-- helper function to determine if a character can be pushed upwards by a certain amount
-- FILL THIS OUT!!!  -- character is 5 studs tall, we&apos;ll check a 1.5 x 1.5 x 4.5 box around char, with center .5 studs below torsocenter
function spaceAboveCharacter(charTorso, newTorsoY)
	local partsAboveChar = game.Workspace:FindPartsInRegion3(Region3.new(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75), Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)), charTorso.Parent, 100)
	for j = 1, #partsAboveChar do
		if partsAboveChar[j].CanCollide then return false end
	end

	return true
end



local insertBoundingBoxOverlapVector = Vector3.new(1, 1, 1) -- we can still stamp if our character extrudes into the target stamping space by 1 or fewer units

function onInsertMouseButton1Up()
	if Data.Stamp.MouseDown then
		Data.Stamp.MouseDown = false
		if Data.Stamp.Dragger then

			--Place the object where the mouse is currently positioned
			-- For Restricting Stamper Tool

			while Data.Stamp.MouseLock do wait() end
			onInsertMouseMove()
			Data.Stamp.MouseLock = true

			if(isRestricted) then
				-- if player trys to stamp out of bounds, tell them they can&apos;t
				if not inBounds(Data.Stamp.TransparencyTable) then
					variables.ShowInvalidPlacement.Value = true
					Data.Stamp.MouseLock = false
					return
				end
			end

			-- Prevent part from being stamped on top of a player

			local minBB, maxBB = getBoundingBox2(Data.Stamp.CurrentParts[1])
			local configFound, targetCFrame = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)

			if configFound then
				local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(minBB+targetCFrame.p+insertBoundingBoxOverlapVector, maxBB+targetCFrame.p-insertBoundingBoxOverlapVector), Data.Stamp.CurrentParts[1], 100)
				for b = 1, #blockingParts do
					-- below if we only want to block stamping on self
					--if blockingParts[b].Parent == script.Parent.Parent then return end
					
					-- below if we want to block stamping on self and also stamping that intersects a model we&apos;ve previously stamped on our baseplate
					--		  should work as soon as Region3 queries are fixed
					--      NOTE TO SELF:  See if partModel applies when isRestricted is false
					--if blockingParts[b]:IsDescendantOf(partModel) or blockingParts[b].Parent == script.Parent.Parent then Data.Stamp.MouseLock = false flashRedBox() break end --return end
					if blockingParts[b]:IsDescendantOf(partModel) then Data.Stamp.MouseLock = false flashRedBox() end-- still error if overlapping another model [should return here too!]
				end

				local alreadyPushedUp = {}
				-- if no blocking model below, then see if stamping on top of a character
				for b = 1, #blockingParts do
					--if blockingParts[b].Parent == script.Parent.Parent then
--						local blockingPersonTorso = script.Parent.Parent:FindFirstChild(&quot;Torso&quot;)
						if blockingParts[b].Parent and not alreadyPushedUp[blockingParts[b].Parent] and blockingParts[b].Parent:FindFirstChild(&quot;Humanoid&quot;) and blockingParts[b].Parent:FindFirstChild(&quot;Humanoid&quot;):IsA(&quot;Humanoid&quot;) then
						local blockingPersonTorso = blockingParts[b].Parent:FindFirstChild(&quot;Torso&quot;)
						alreadyPushedUp[blockingParts[b].Parent] = true

						if blockingPersonTorso then
							-- if so, let&apos;s push the person upwards so they pop on top of the stamped model/part (but only if there&apos;s space above them)
							local newY = maxBB.Y + targetCFrame.p.Y + 3
							if spaceAboveCharacter(blockingPersonTorso, newY) then
								blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
							else
								-- if no space, we just error
								Data.Stamp.MouseLock = false
								flashRedBox()
								return
								-- should return here too!
							end
						end
						
						--break
					end
				end
			end

			-- Post process: after positioning the part or model, restore transparency, material, anchored and collide states and create joints
			if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
				
				if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) then
					-- Tyler&apos;s magical hack-code for allowing/preserving clones of both Surface and Manual Welds...  just don&apos;t ask X&lt;
					manualWeldTable = {}
					manualWeldParentTable = {}
					saveTheWelds(Data.Stamp.CurrentParts[1])
					Data.Stamp.CurrentParts[1]:BreakJoints()
					Data.Stamp.CurrentParts[1]:MakeJoints()
					restoreTheWelds()
				end
				
				-- if it&apos;s a model, we also want to fill in the playerID and playerName tags, if it has those (e.g. for the friend-only door)
				playerIdTag = Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;PlayerIdTag&quot;)
				playerNameTag = Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;PlayerNameTag&quot;)
				if playerIdTag ~= nil then
					tempPlayerValue = getPlayer()
					if tempPlayerValue ~= nil then playerIdTag.Value = tempPlayerValue.userId end
				end
				if playerNameTag ~= nil then
					tempPlayerValue = getPlayer()
					if tempPlayerValue ~= nil then playerNameTag.Value = tempPlayerValue.Name end
				end
				-- ...and tag all inserted models for subsequent origin identification
				-- if no RobloxModel tag already exists, then add it.
				if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;RobloxModel&quot;) == nil then
					local stringTag = Instance.new(&quot;BoolValue&quot;, Data.Stamp.CurrentParts[1])
					stringTag.Name = &quot;RobloxModel&quot;

					if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;RobloxStamper&quot;) == nil then
						local stringTag2 = Instance.new(&quot;BoolValue&quot;, Data.Stamp.CurrentParts[1])
						stringTag2.Name = &quot;RobloxStamper&quot;
					end
				end

			else
				Data.Stamp.CurrentParts[1]:BreakJoints()
				if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;RobloxStamper&quot;) == nil then
					local stringTag2 = Instance.new(&quot;BoolValue&quot;, Data.Stamp.CurrentParts[1])
					stringTag2.Name = &quot;RobloxStamper&quot;
				end
			end
			
			-- make sure all the joints are activated before restoring anchor states
			if not createJoints then game.JointsService:CreateJoinAfterMoveJoints() end

			--Fix the transparency and material of all the parts
			for part, transparency in pairs(Data.Stamp.TransparencyTable) do
				part.Transparency = transparency
				part.archivable = true
			end
			for part, material in pairs(Data.Stamp.MaterialTable) do
				part.Material = material
			end
			for part, collide in pairs(Data.Stamp.CanCollideTable) do
				part.CanCollide = collide
			end
			for part, anchored in pairs(Data.Stamp.AnchoredTable) do
				part.Anchored = anchored
			end
			for decal, transparency in pairs(Data.Stamp.DecalTransparencyTable) do
				decal.Transparency = transparency
			end

			-- re-enable all seats
			setSeatEnabledStatus(Data.Stamp.CurrentParts[1], true)

			Data.Stamp.TransparencyTable = nil
			Data.Stamp.MaterialTable = nil
			Data.Stamp.CanCollideTable = nil
			Data.Stamp.AnchoredTable = nil

			-- ...and tag all inserted models for subsequent origin identification
			-- if no RobloxModel tag already exists, then add it.
			if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;RobloxModel&quot;) == nil then
				local stringTag = Instance.new(&quot;BoolValue&quot;, Data.Stamp.CurrentParts[1])
				stringTag.Name = &quot;RobloxModel&quot;
			end
						
			-- set our object back to the player&apos;s plate
			Data.Stamp.CurrentParts[1].Parent = partModel

			--Re-enable the scripts
			for index,script in pairs(Data.Stamp.DisabledScripts) do
				script.Disabled = false
			end
			--Now that they are all marked enabled, reinsert them into the world so they start running
			for index,script in pairs(Data.Stamp.DisabledScripts) do
				local oldParent = script.Parent
				script.Parent = nil
				script:Clone().Parent = oldParent
			end
			Data.Stamp.DisabledScripts = nil
			Data.Stamp.Dragger = nil
			Data.Stamp.CurrentParts.Parent = nil
			Data.Stamp.CurrentParts = nil

			Data.Stamp.MouseLock = false

			--Now set up a new instance of the object to allow a second copy to be stamped down
			variables.Stamped.Value = true
			variables.Stamped.Value = false
			if isRestricted then
				if checkPartLimit() then
					setupDraggableClone()
				else
					variables.ShowMaxedOut.Value = true
				end
			else
				setupDraggableClone()
			end

		end
	end
end


------------------------ EyeDropper Code -------------------------------------------

function disconnectAllWires(instance)
	if instance:IsA(&quot;CustomEvent&quot;) then
		for idx, recv in ipairs(instance:GetAttachedReceivers()) do
			instance:Disconnect(recv)
		end
	elseif instance:IsA(&quot;CustomEventReceiver&quot;) then
		for idx, sender in ipairs(instance:GetAttachedEvents()) do
			sender:Disconnect(instance)
		end
	else
		for idx, child in ipairs(instance:GetChildren()) do
			disconnectAllWires(child)
		end
	end
end

function onEyeDropperMouseButton1Down()

	if eyeDropperConnection then 
		eyeDropperConnection:disconnect()
	end
	if eyeDropperMoveConnection then 
		eyeDropperMoveConnection:disconnect()
	end
	clearSelection()
	Mouse.Icon = &quot;rbxasset://textures//ArrowCursor.png&quot;

	-- deny any attempt to clone something that wasn&apos;t stamped using the Stamper tool
	local stamperTag = Mouse.Target.Parent:FindFirstChild(&quot;RobloxStamper&quot;)
	if stamperTag == nil then stamperTag = Mouse.Target:FindFirstChild(&quot;RobloxStamper&quot;) end
	if stamperTag == nil then 
		startEyeDropperOperation()
		return 
	end

	local eyeDropperInstance
	-- find out if the target part is part of a Roblox Set Model
	local robloxModelTag = Mouse.Target.Parent:FindFirstChild(&quot;RobloxModel&quot;)
	if robloxModelTag ~= nil then
		eyeDropperInstance = Mouse.Target.Parent
	else
		eyeDropperInstance = Mouse.Target
	end
	
	-- do not allow certain objects to be captured with eye-dropper
	-- for now, locked parts
	if eyeDropperInstance:IsA(&quot;Part&quot;) and eyeDropperInstance.Locked then
		startEyeDropperOperation()
	else
		local cloneInstance = eyeDropperInstance:clone()
		disconnectAllWires(cloneInstance)
		local tempModel = Instance.new(&quot;Model&quot;)
		cloneInstance.Parent = tempModel

		Data.Stamp.Model = tempModel
		Data.Stamp.Model:BreakJoints()

		-- will create and position clone without requiring user to move the mouse
		if isRestricted then
			if checkPartLimit() then
				setupDraggableClone()
			else
				variables.ShowMaxedOut.Value = true
			end
		else
			setupDraggableClone()
		end
		variables.SwitchLoaderToDialog.AssetImage.Value = &quot;0&quot;
		variables.SwitchLoaderToDialog.DialogType.Value = &quot;SideDialog&quot;
		variables.SwitchLoaderToDialog.Value = true
	end

end

function onEyeDropperMouseMove() 
	if not(inGui) and not(inPalette) then
		local part = Mouse.Target
		if canEyeDropperObject(part) then
			local model = findModel(part)
			if model then 		
				selectionBox.Color = BrickColor.Green()
				setSelection(model)
			else
				selectionBox.Color = BrickColor.Green()
				setSelection(part)
			end
		else
			clearSelection()
		end
	end
end

function startEyeDropperOperation()

	cancelAssetPlacement()
	pressedEsc = false
	signalInsertComplete(&quot;EyeDropper&quot;)
--[[	if deleteButtonDownConnection then deleteButtonDownConnection:disconnect() end
	if deleteMoveConnection then deleteMoveConnection:disconnect() end]]
	if eyeDropperConnection then eyeDropperConnection:disconnect() end
	if eyeDropperMoveConnection then eyeDropperMoveConnection:disconnect() end
	Mouse.Icon =&quot;rbxasset://textures//DropperCursor.png&quot;
	eyeDropperConnection = Mouse.Button1Up:connect(onEyeDropperMouseButton1Down)
	eyeDropperMoveConnection = Mouse.Move:connect(onEyeDropperMouseMove)

end

function findModel(part)

	if isRestricted then
		while part ~= nil do
			if part.className == &quot;Model&quot; and part.Name ~= playerModel.Name and part.Name ~= &quot;GarbageParts&quot; then
				return part
			elseif part.Name == playerModel.Name or part.Name == &quot;GarbageParts&quot; then
				return nil
			end
			part = part.Parent
		end
		return nil

	else
		while part ~= game.Workspace do
			if part:FindFirstChild(&quot;RobloxModel&quot;) then
				return part
			end
			part = part.Parent
		end
		return nil
	end

end

------------------------ End EyeDropper Code ---------------------------------------




------------------------ Start Selection Highlighting Code --------------------------
	
function setSelection(partOrModel)
	if partOrModel ~= currentSelection then
		clearSelection()
		currentSelection = partOrModel
		selectionBox.Adornee = currentSelection
	end
end

function clearSelection()
	if currentSelection ~= nil then
		for part, color in pairs(currentSelectionColors) do
			part.BrickColor = color
		end
		selectionBox.Adornee = nil
	end
	currentSelectionColors = {}
	-- I put these inside if statements, because we can&apos;t assume these exist. (Jahr, 12-29-2010)
	if currentSelection then currentSelection = nil end
	if selectionBox then selectionBox.Adornee = nil end
end

------------------------ End Selection Highlighting Code --------------------------



function onInsertKeyDown(key)

	if Data.Stamp.Dragger then
		if key == &apos;R&apos; or key == &apos;r&apos;  then
			-- Rotate the parts or all the parts in the model
			local ry = math.pi/2
			local rotCF = CFrame.fromEulerAnglesXYZ(0, ry, 0)
			gInitial90DegreeRotations = gInitial90DegreeRotations + 1 
			if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
				for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
					if object:IsA(&quot;Flag&quot;) then object = object.Handle end
					if object:IsA(&quot;Part&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;Seat&quot;) or object:IsA(&quot;VehicleSeat&quot;) then
						object.CFrame = rotCF * object.CFrame
					end
				end
			else
				Data.Stamp.CurrentParts[1].CFrame = rotCF * Data.Stamp.CurrentParts[1].CFrame
			end
			-- After rotating, update the position
			configFound, targetCFrame = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)
			if configFound then
				positionPartsAtCFrame3(Data.Stamp.CurrentParts[1], targetCFrame)
			end
		end
	end
	if key == &apos;E&apos; or key == &apos;e&apos;  then
		startEyeDropperOperation()
	elseif key == &apos;P&apos; or key ==&apos;p&apos; then
		pressedEsc = true
		if eyeDropperConnection then eyeDropperConnection:disconnect() end
		if eyeDropperMoveConnection then eyeDropperMoveConnection:disconnect() end
		clearSelection()
		cancelAssetPlacement()
		Data.Loading.Cancelled = true
		signalInsertComplete(&quot;Main&quot;)
	end

end


function onEquippedLocal(mouse)

	Mouse = mouse

	player = getPlayer()

	-- if equip goes through while in backpack (so getPlayer() returns nil), we don&apos;t want to process anything else
	if not player then return end

	if isRestricted then
		if game.Workspace:FindFirstChild(&quot;BuildingAreas&quot;) then
			local areas = game.Workspace.BuildingAreas:GetChildren()
			for i = 1, #areas do
				if areas[i]:FindFirstChild(&quot;Player&quot;) and areas[i].Player.Value == Tool.Parent.Name then
					playerModel = areas[i]:FindFirstChild(&quot;PlayerArea&quot;)
					break
				end
			end
		end
	else
		playerModel = game.Workspace
	end

	if not playerModel then return end

	mouseMoveCon = mouse.Move:connect(onInsertMouseMove)
	mouseButton1DownCon = mouse.Button1Down:connect(onInsertMouseButton1Down)
	mouseButton1UpCon = mouse.Button1Up:connect(onInsertMouseButton1Up)
	Mouse.KeyDown:connect(onInsertKeyDown)

	if(isRestricted) then
		local takenAreas = game.Workspace.BuildingAreas:GetChildren()

		waitForChild(player, &quot;playerNumber&quot;)

		if(player.playerNumber.Value == 0) then
			buildingPlate = nil
			partModel = nil
		else
			waitForChild(game.Workspace, &quot;BuildingAreas&quot;)
			local buildingAreas = game.Workspace.BuildingAreas
			waitForChild(buildingAreas, &quot;Area&quot;..tostring(player.playerNumber.Value))
			local targetArea = buildingAreas:FindFirstChild(&quot;Area&quot;..tostring(player.playerNumber.Value))
			
			waitForChild(targetArea, &quot;PlayerArea&quot;)
			waitForChild(targetArea.PlayerArea, &quot;BasePlate&quot;)

			buildingPlate = targetArea.PlayerArea.BasePlate
			partModel = targetArea.PlayerArea
		end
	else
		partModel = game.Workspace
	end

	selectionBox = Instance.new(&quot;SelectionBox&quot;)
	selectionBox.Name = &quot;Model Delete Selection&quot;
	selectionBox.Color = BrickColor.Red()
	selectionBox.Adornee = nil
	selectionBox.Parent = player.PlayerGui

	alreadyMoving = false
end


function onUnequipped()
	if mouseMoveCon then mouseMoveCon:disconnect() end
	if mouseButton1DownCon then mouseButton1DownCon:disconnect() end
	if mouseButton1UpCon then mouseButton1UpCon:disconnect() end

	cancelAssetPlacement()

	clearSelection()
	if selectionBox then selectionBox:Remove() end
end
----------------------------------------------------------------------------------------




-- Lua Start Script
Tool.Equipped:connect(function(Mouse) onEquippedLocal(Mouse) end)

waitForChild(variables,&quot;InsertAsset&quot;)
waitForChild(variables.InsertAsset, &quot;Updated&quot;)
variables.InsertAsset.Updated.Changed:connect(function(prop)
	if variables.InsertAsset.Updated.Value == true then
		pressedEsc = false
		beginInsertAssetStamp(variables.InsertAsset.AssetName.Value, variables.InsertAsset.AssetId.Value,
			variables.InsertAsset.Image.Value, variables.InsertAsset.StampMode.Value)
		variables.InsertAsset.Updated.Value = false
	end
end)

waitForChild(variables, &quot;SwitchMode&quot;)
waitForChild(variables.SwitchMode, &quot;Mode&quot;)
variables.SwitchMode.Changed:connect(function()
	if variables.SwitchMode.Value == true then
		if variables.SwitchMode.Mode.Value == &quot;Clone&quot; then
			startEyeDropperOperation()
		end
		variables.SwitchMode.Value = false
	end
end)

Tool.Unequipped:connect(function() onUnequipped() end)
----------------------------------------------------------------------------------------
</ProtectedString>
			</Properties>
		</Item>
		<Item class="ScreenGui" referent="RBX40">
			<Properties>
				<bool name="Archivable">true</bool>
				<string name="Name">StampGUI</string>
			</Properties>
			<Item class="Frame" referent="RBX41">
				<Properties>
					<bool name="Active">true</bool>
					<bool name="Archivable">true</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="Draggable">false</bool>
					<string name="Name">InsertPanel</string>
					<UDim2 name="Position">
						<XS>0.200000003</XS>
						<XO>2</XO>
						<YS>0.100000001</YS>
						<YO>24</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0.600000024</XS>
						<XO>-20</XO>
						<YS>0.639999986</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">3</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX42">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="Archivable">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="Draggable">false</bool>
						<string name="Name">ItemsFrame</string>
						<UDim2 name="Position">
							<XS>0.239999995</XS>
							<XO>0</XO>
							<YS>0.0850000009</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.540000021</XS>
							<XO>0</XO>
							<YS>0.800000012</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX43">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="Archivable">true</bool>
							<Color3 name="BackgroundColor3">4294112243</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="Draggable">false</bool>
							<string name="Name">InsertAssetButtonExample</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>128</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>64</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="TextButton" referent="RBX44">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="Archivable">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4282861383</Color3>
								<float name="BackgroundTransparency">0.100000001</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">0</token>
								<string name="Name">Button</string>
								<UDim2 name="Position">
									<XS>0.0250000004</XS>
									<XO>0</XO>
									<YS>0.0250000004</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0.949999988</XS>
									<XO>0</XO>
									<YS>0.949999988</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4279970357</Color3>
								<float name="TextTransparency">0.100000001</float>
								<bool name="TextWrap">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX45">
								<Properties>
									<bool name="Active">false</bool>
									<bool name="Archivable">true</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://gametest.roblox.com/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=209411115</url></Content>
									<string name="Name">ButtonImage</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-8</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>16</XO>
										<YS>1</YS>
										<YO>16</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="IntValue" referent="RBX46">
							<Properties>
								<bool name="Archivable">true</bool>
								<string name="Name">AssetId</string>
								<int name="Value">209411115</int>
							</Properties>
						</Item>
						<Item class="StringValue" referent="RBX47">
							<Properties>
								<bool name="Archivable">true</bool>
								<string name="Name">AssetName</string>
								<string name="Value">Roof - Outer Corner</string>
							</Properties>
						</Item>
						<Item class="ImageLabel" referent="RBX48">
							<Properties>
								<bool name="Active">false</bool>
								<bool name="Archivable">true</bool>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset?id=54140547</url></Content>
								<string name="Name">ConfigIcon</string>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>-23</XO>
									<YS>1</YS>
									<YO>-24</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>16</XO>
									<YS>0</YS>
									<YO>16</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX49">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="Archivable">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">7</token>
						<string name="Name">CancelButton</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-32</XO>
							<YS>0</YS>
							<YO>-2</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>34</XO>
							<YS>0</YS>
							<YO>34</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">1</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<float name="TextTransparency">0</float>
						<bool name="TextWrap">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX50">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="Archivable">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset?id=54135717</url></Content>
							<string name="Name">ImageLabel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-2</XO>
								<YS>0</YS>
								<YO>-2</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>16</XO>
								<YS>0</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX51">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="Archivable">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">5</token>
						<string name="Name">SelectSetButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0.200000003</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">1</token>
						<string name="Text">Select Set</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<float name="TextTransparency">0</float>
						<bool name="TextWrap">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX52">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="Archivable">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="Draggable">false</bool>
						<string name="Name">PagingControls</string>
						<UDim2 name="Position">
							<XS>0.239999995</XS>
							<XO>0</XO>
							<YS>0.899999976</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.540000021</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="TextButton" referent="RBX53">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="Archivable">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<string name="Name">PreviousPageButton</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>-95</XO>
								<YS>0.5</YS>
								<YO>-20</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>60</XO>
								<YS>0</YS>
								<YO>40</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<float name="TextTransparency">0</float>
							<bool name="TextWrap">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX54">
							<Properties>
								<bool name="Active">false</bool>
								<bool name="Archivable">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset?id=54138586</url></Content>
								<string name="Name">ImageLabel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>8</XO>
									<YS>0</YS>
									<YO>-1</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>18</XO>
									<YS>0</YS>
									<YO>18</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX55">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="Archivable">true</bool>
							<Color3 name="BackgroundColor3">4284874854</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<string name="Name">PageText</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>-30</XO>
								<YS>0.5</YS>
								<YO>-20</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>60</XO>
								<YS>0</YS>
								<YO>40</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">1 / 3</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<float name="TextTransparency">0</float>
							<bool name="TextWrap">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX56">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="Archivable">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<string name="Name">NextPageButton</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>35</XO>
								<YS>0.5</YS>
								<YO>-20</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>60</XO>
								<YS>0</YS>
								<YO>40</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<float name="TextTransparency">0</float>
							<bool name="TextWrap">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX57">
							<Properties>
								<bool name="Active">false</bool>
								<bool name="Archivable">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset?id=54138563</url></Content>
								<string name="Name">ImageLabel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>10</XO>
									<YS>0</YS>
									<YO>-1</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>18</XO>
									<YS>0</YS>
									<YO>18</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX58">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="Archivable">true</bool>
						<Color3 name="BackgroundColor3">4294901862</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="Draggable">false</bool>
						<string name="Name">Sets</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.230000004</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>-5</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX59">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="Archivable">true</bool>
							<Color3 name="BackgroundColor3">4294967295</Color3>
							<float name="BackgroundTransparency">0.699999988</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="Draggable">false</bool>
							<string name="Name">Line</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-3</XO>
								<YS>0.0599999987</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>3</XO>
								<YS>0.899999976</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX60">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="Archivable">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<string name="Name">SetsHeader</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>47</XO>
								<YS>0</YS>
								<YO>24</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Sets</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<float name="TextTransparency">0</float>
							<bool name="TextWrap">false</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX61">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="Archivable">true</bool>
							<Color3 name="BackgroundColor3">4291559577</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="Draggable">false</bool>
							<string name="Name">SetsLists</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0.0599999987</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-6</XO>
								<YS>0.939999998</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="TextButton" referent="RBX62">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="Archivable">true</bool>
								<bool name="AutoButtonColor">false</bool>
								<Color3 name="BackgroundColor3">4294967295</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="Draggable">false</bool>
								<token name="Font">1</token>
								<token name="FontSize">6</token>
								<string name="Name">SetButtonExample</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>18</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-5</XO>
									<YS>0</YS>
									<YO>18</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<string name="Text">House Decorations</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<float name="TextTransparency">0</float>
								<bool name="TextWrap">true</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX63">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="Archivable">true</bool>
						<Color3 name="BackgroundColor3">4284874803</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="Draggable">false</bool>
						<string name="Name">ItemPreview</string>
						<UDim2 name="Position">
							<XS>0.790000021</XS>
							<XO>0</XO>
							<YS>0.0850000009</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.209999993</XS>
							<XO>0</XO>
							<YS>0.899999976</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX64">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="Archivable">true</bool>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">0.5</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://gametest.roblox.com/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=209433914</url></Content>
							<string name="Name">LargePreview</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>170</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX65">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="Archivable">true</bool>
							<Color3 name="BackgroundColor3">4286578816</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="Draggable">false</bool>
							<string name="Name">TextPanel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0.449999988</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.550000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="TextLabel" referent="RBX66">
							<Properties>
								<bool name="Active">false</bool>
								<bool name="Archivable">true</bool>
								<Color3 name="BackgroundColor3">4291624857</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">7</token>
								<string name="Name">RolloverText</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>48</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">Window - Diagonal</string>
								<Color3 name="TextColor3">4294112243</Color3>
								<float name="TextTransparency">0</float>
								<bool name="TextWrap">true</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX67">
							<Properties>
								<bool name="Active">false</bool>
								<bool name="Archivable">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="Draggable">false</bool>
								<string name="Name">ConfigureText</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>48</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>-48</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBX68">
								<Properties>
									<bool name="Active">false</bool>
									<bool name="Archivable">true</bool>
									<Color3 name="BackgroundColor3">4294901862</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">Configure</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>14</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">Configure:</string>
									<Color3 name="TextColor3">4294112243</Color3>
									<float name="TextTransparency">0</float>
									<bool name="TextWrap">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX69">
								<Properties>
									<bool name="Active">false</bool>
									<bool name="Archivable">true</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="Draggable">false</bool>
									<token name="Font">1</token>
									<token name="FontSize">5</token>
									<string name="Name">Configure1</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>14</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>14</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">Speed</string>
									<Color3 name="TextColor3">4294112243</Color3>
									<float name="TextTransparency">0</float>
									<bool name="TextWrap">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX70">
								<Properties>
									<bool name="Active">false</bool>
									<bool name="Archivable">true</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="Draggable">false</bool>
									<token name="Font">1</token>
									<token name="FontSize">5</token>
									<string name="Name">Configure2</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>28</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>14</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">Damage</string>
									<Color3 name="TextColor3">4294112243</Color3>
									<float name="TextTransparency">0</float>
									<bool name="TextWrap">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX71">
								<Properties>
									<bool name="Active">false</bool>
									<bool name="Archivable">true</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="Draggable">false</bool>
									<token name="Font">1</token>
									<token name="FontSize">5</token>
									<string name="Name">Configure3</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>42</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>14</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">Delay</string>
									<Color3 name="TextColor3">4294112243</Color3>
									<float name="TextTransparency">0</float>
									<bool name="TextWrap">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX72">
				<Properties>
					<bool name="Active">true</bool>
					<bool name="Archivable">true</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="Draggable">false</bool>
					<string name="Name">StamperPanel</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-175</XO>
						<YS>1</YS>
						<YO>-135</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>350</XO>
						<YS>0</YS>
						<YO>48</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">3</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">2</int>
				</Properties>
				<Item class="TextButton" referent="RBX73">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="Archivable">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">7</token>
						<string name="Name">MinimizeButton</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-32</XO>
							<YS>0</YS>
							<YO>-2</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>34</XO>
							<YS>0</YS>
							<YO>34</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">1</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<float name="TextTransparency">0</float>
						<bool name="TextWrap">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">3</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX74">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="Archivable">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset?id=54932670</url></Content>
							<string name="Name">ImageLabel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-3</XO>
								<YS>0</YS>
								<YO>-4</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>16</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">4</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX75">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="Archivable">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="Draggable">false</bool>
						<string name="Name">StamperButtons</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX76">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="Archivable">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="Draggable">false</bool>
							<string name="Name">RecentFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>103</XO>
								<YS>0</YS>
								<YO>-6</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>192</XO>
								<YS>0</YS>
								<YO>44</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="TextButton" referent="RBX77">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="Archivable">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4282861383</Color3>
								<float name="BackgroundTransparency">0.100000001</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">0</token>
								<string name="Name">Button1</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>48</XO>
									<YS>0</YS>
									<YO>48</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4294967295</Color3>
								<float name="TextTransparency">0.100000001</float>
								<bool name="TextWrap">false</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">0</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">4</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX78">
								<Properties>
									<bool name="Active">false</bool>
									<bool name="Archivable">true</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://gametest.roblox.com/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=209434543</url></Content>
									<string name="Name">ButtonImage</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-8</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>16</XO>
										<YS>1</YS>
										<YO>16</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">5</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX79">
								<Properties>
									<bool name="Active">false</bool>
									<bool name="Archivable">true</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">ShortcutText</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>7</XO>
										<YS>0</YS>
										<YO>12</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">F</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<float name="TextTransparency">0</float>
									<bool name="TextWrap">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">8</int>
								</Properties>
							</Item>
						</Item>
						<Item class="TextButton" referent="RBX80">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="Archivable">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4282861383</Color3>
								<float name="BackgroundTransparency">0.100000001</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">0</token>
								<string name="Name">Button2</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>48</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>48</XO>
									<YS>0</YS>
									<YO>48</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4279970357</Color3>
								<float name="TextTransparency">0.100000001</float>
								<bool name="TextWrap">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">4</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX81">
								<Properties>
									<bool name="Active">false</bool>
									<bool name="Archivable">true</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://gametest.roblox.com/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=209434543</url></Content>
									<string name="Name">ButtonImage</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-8</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>16</XO>
										<YS>1</YS>
										<YO>16</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">5</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX82">
								<Properties>
									<bool name="Active">false</bool>
									<bool name="Archivable">true</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">ShortcutText</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>7</XO>
										<YS>0</YS>
										<YO>12</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">G</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<float name="TextTransparency">0</float>
									<bool name="TextWrap">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">8</int>
								</Properties>
							</Item>
						</Item>
						<Item class="TextButton" referent="RBX83">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="Archivable">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4282861383</Color3>
								<float name="BackgroundTransparency">0.100000001</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">0</token>
								<string name="Name">Button3</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>95</XO>
									<YS>0</YS>
									<YO>-3</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>48</XO>
									<YS>0</YS>
									<YO>48</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4279970357</Color3>
								<float name="TextTransparency">0.100000001</float>
								<bool name="TextWrap">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">4</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX84">
								<Properties>
									<bool name="Active">false</bool>
									<bool name="Archivable">true</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://gametest.roblox.com/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=209434543</url></Content>
									<string name="Name">ButtonImage</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-8</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>16</XO>
										<YS>1</YS>
										<YO>16</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">5</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX85">
								<Properties>
									<bool name="Active">false</bool>
									<bool name="Archivable">true</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">ShortcutText</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>7</XO>
										<YS>0</YS>
										<YO>12</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">H</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<float name="TextTransparency">0</float>
									<bool name="TextWrap">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">8</int>
								</Properties>
							</Item>
						</Item>
						<Item class="TextButton" referent="RBX86">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="Archivable">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4282861383</Color3>
								<float name="BackgroundTransparency">0.100000001</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">0</token>
								<string name="Name">Button4</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>142</XO>
									<YS>0</YS>
									<YO>-3</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>48</XO>
									<YS>0</YS>
									<YO>48</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4279970357</Color3>
								<float name="TextTransparency">0.100000001</float>
								<bool name="TextWrap">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">4</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX87">
								<Properties>
									<bool name="Active">false</bool>
									<bool name="Archivable">true</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://gametest.roblox.com/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=209434543</url></Content>
									<string name="Name">ButtonImage</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-8</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>16</XO>
										<YS>1</YS>
										<YO>16</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">5</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX88">
								<Properties>
									<bool name="Active">false</bool>
									<bool name="Archivable">true</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">ShortcutText</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>7</XO>
										<YS>0</YS>
										<YO>12</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">J</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<float name="TextTransparency">0</float>
									<bool name="TextWrap">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">8</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBX89">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="Archivable">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">5</token>
							<string name="Name">CloneButton</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>-6</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>45</XO>
								<YS>0</YS>
								<YO>45</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<float name="TextTransparency">0</float>
							<bool name="TextWrap">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX90">
							<Properties>
								<bool name="Active">false</bool>
								<bool name="Archivable">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset?id=51641555</url></Content>
								<string name="Name">ImageLabel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-7</XO>
									<YS>0</YS>
									<YO>-7</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>14</XO>
									<YS>1</YS>
									<YO>14</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">4</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX91">
							<Properties>
								<bool name="Active">false</bool>
								<bool name="Archivable">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">5</token>
								<string name="Name">CloneShortcut</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-7</XO>
									<YS>0</YS>
									<YO>-8</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>8</XO>
									<YS>0</YS>
									<YO>12</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">E</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<float name="TextTransparency">0</float>
								<bool name="TextWrap">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">5</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBX92">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="Archivable">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">5</token>
							<string name="Name">PartsButton</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>45</XO>
								<YS>0</YS>
								<YO>-6</YO>
							</UDim2>
							<bool name="Selected">true</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>45</XO>
								<YS>0</YS>
								<YO>45</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<float name="TextTransparency">0</float>
							<bool name="TextWrap">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX93">
							<Properties>
								<bool name="Active">false</bool>
								<bool name="Archivable">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset?id=54966682</url></Content>
								<string name="Name">ImageLabel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-7</XO>
									<YS>0</YS>
									<YO>-7</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>14</XO>
									<YS>1</YS>
									<YO>14</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">4</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX94">
							<Properties>
								<bool name="Active">false</bool>
								<bool name="Archivable">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">5</token>
								<string name="Name">PartsShortcut</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-7</XO>
									<YS>0</YS>
									<YO>-8</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>8</XO>
									<YS>0</YS>
									<YO>12</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">P</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<float name="TextTransparency">0</float>
								<bool name="TextWrap">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">5</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX95">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="Archivable">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="Draggable">false</bool>
							<string name="Name">ClonePanel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>-8</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>80</XO>
								<YS>1</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="TextLabel" referent="RBX96">
							<Properties>
								<bool name="Active">false</bool>
								<bool name="Archivable">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">5</token>
								<string name="Name">ClonePanelText</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-6</XO>
									<YS>0</YS>
									<YO>-8</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>12</XO>
									<YS>1</YS>
									<YO>16</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">Click on a part to clone it</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<float name="TextTransparency">0</float>
								<bool name="TextWrap">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX97">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="Archivable">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">7</token>
						<string name="Name">RestoreButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>-25</XO>
							<YS>0</YS>
							<YO>-20</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>50</XO>
							<YS>0</YS>
							<YO>25</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">1</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<float name="TextTransparency">0</float>
						<bool name="TextWrap">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">3</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX98">
						<Properties>
							<bool name="Active">false</bool>
							<bool name="Archivable">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.roblox.com/asset?id=54933540</url></Content>
							<string name="Name">ImageLabel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-4</XO>
								<YS>0</YS>
								<YO>-4</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>8</XO>
								<YS>1</YS>
								<YO>8</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">4</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX99">
				<Properties>
					<bool name="Archivable">true</bool>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StampGuiController</string>
					<ProtectedString name="Source">local stampGui = script.Parent
local insertPanel = stampGui.InsertPanel
local stamperPanel = stampGui.StamperPanel

local itemPreview = insertPanel.ItemPreview

function handleResize()
	wait() -- neccessary to insure heartbeat happened
	itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
	itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
	itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
	itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
end

stampGui.Changed:connect(function(prop)
	if prop == &quot;AbsoluteSize&quot; then
		handleResize()
	end
end)

handleResize()</ProtectedString>
				</Properties>
			</Item>
			<Item class="Frame" referent="RBX100">
				<Properties>
					<bool name="Active">false</bool>
					<bool name="Archivable">true</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="Draggable">false</bool>
					<string name="Name">LoadDialog</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-175</XO>
						<YS>0.5</YS>
						<YO>-25</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>350</XO>
						<YS>0</YS>
						<YO>50</YO>
					</UDim2>
					<token name="SizeConstraint">1</token>
					<token name="Style">3</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextLabel" referent="RBX101">
					<Properties>
						<bool name="Active">false</bool>
						<bool name="Archivable">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">8</token>
						<string name="Name">LoadLabel</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>-8</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>155</XO>
							<YS>0.5</YS>
							<YO>36</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Loading...</string>
						<Color3 name="TextColor3">4294506744</Color3>
						<float name="TextTransparency">0</float>
						<bool name="TextWrap">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX102">
			<Properties>
				<bool name="Archivable">true</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">GuiScript</string>
				<ProtectedString name="Source">-- This script is responsible for working the gui

-- basic functions
function waitForChild(instance, name)
	while not instance:findFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

function waitForProperty(instance, name)
	while not instance[name] do
		instance.Changed:wait()
	end
end


-- Locals
local Tool = script.Parent

waitForChild(Tool, &quot;LuaGlobalVariables&quot;)
local variables = Tool.LuaGlobalVariables
waitForChild(variables, &quot;InsertAsset&quot;)
local insertAsset = variables.InsertAsset
waitForChild(variables, &quot;SwitchMode&quot;)
local switchMode = variables.SwitchMode
waitForChild(variables, &quot;ShowAdminCategories&quot;)
local showAdminCategories = variables.ShowAdminCategories

waitForChild(variables,&quot;userIDs&quot;)

game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=42163425&quot;)
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=42563487&quot;)

local buttonHeight = 64
local buttonWidth = buttonHeight

local waypointShowing = false

local firstEquip = true

local Window
local Data
local loading = false

local SetCache = {}

-- For Restricting Stamper Tool
local isRestricted = variables.IsRestricted
local buildingPlate
local partModel

-- wait for all of our set ids to load
local userIdsForStamperParts = variables.userIDs -- 7502714 This is UsabilityMan (on gametest)
while #userIdsForStamperParts:GetChildren() &lt; userIdsForStamperParts.Value do userIdsForStamperParts.ChildAdded:wait() end
userIdsForStamperParts = userIdsForStamperParts:GetChildren()

local useAssetVersionId = true
local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl
local LargeThumbnailUrl
local SmallThumbnailUrl

local InsertRows = 0
local InsertColumns = 0
local insertButtons = {}

local CancelDuringLoad

local prevPart = {AssetNameValue = &quot;&quot;,AssetIdValue = 0 ,InsertFrameButtonImage = &quot;&quot;}
local recentPartStack = {}

-- Connection Managers
local guiChangedCon = nil
local cloneButtonCon = nil
local partListClickCon = nil
local itemFrameChangedCon = nil
local setsNextPageCon = nil
local setsPrevPageCon = nil
local insertPanelCloseCon = nil
local minimizeCon = nil
local restoreCon = nil
local setButtonCons = {}
local insertButtonCons = {}
local recentPartStackCons = {}

local Mouse = nil
local currSetPage = 1

local mode = 0 -- 0 = main dialog, 1 = stamper, 2 = eyedropper

waitForChild(script.Parent,&quot;StampGUI&quot;)
local stamperGui = script.Parent.StampGUI
waitForChild(stamperGui,&quot;InsertPanel&quot;)
waitForChild(stamperGui.InsertPanel, &quot;CancelButton&quot;)
local currStampGui = nil

local maxRecentParts = 4
for i = 1, maxRecentParts do
	recentPartStack[i] = {AssetNameValue,AssetIdValue,InsertFrameButtonImage}
	recentPartStack[i].AssetNameValue = &quot;&quot;
	recentPartStack[i].AssetIdValue = &quot;&quot;
	recentPartStack[i].InsertFrameButtonImage = &quot;&quot;
end
----------------------------------------------------------------------------------------


-- functions
function showBaseplateGuideArrows()
	playerCharacter = Tool.Parent
	if playerCharacter:FindFirstChild(&quot;Humanoid&quot;) and not playerCharacter:FindFirstChild(&quot;BasePlateGuide&quot;) then
		newGuide = Tool.BasePlateGuide:Clone()
		newGuide.Parent = playerCharacter
		newGuide.Disabled = false
	end
end

function setAssetUrls()
	if useAssetVersionId then
		LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
		SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
	else
		LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
		SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
	end
end

function signalSwitchMode(mode)
	switchMode.Mode.Value = mode
	switchMode.Value = true
end

function goToClone()
	cancelLoadingWindow()
	closeInsertPanel()
	cancelAssetPlacement()

	mode = 2
	signalStamperScript(&quot;&quot;,0,&quot;&quot;,&quot;&quot;,false)
	signalSwitchMode(&quot;Clone&quot;)

	currStampGui.StamperPanel.StamperButtons.ClonePanel.Visible = true
	currStampGui.StamperPanel.StamperButtons.CloneButton.Selected = true
	currStampGui.StamperPanel.StamperButtons.ClonePanel:TweenPosition(UDim2.new(0, -88, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
	delay(0.3,function() currStampGui.StamperPanel.StamperButtons.ClonePanel.ClonePanelText.Visible = true end)
end

function goToStamp()
	mode = 1
	cancelLoadingWindow()
	closeInsertPanel()
	closeClonePanel()
end

function goToInsertPanel()
	cancelLoadingWindow()
	closeClonePanel()
	pcall(function() currStampGui.InsertPanel.CancelButton.Modal = true end)
	currStampGui.StamperPanel.StamperButtons.PartsButton.Selected = true
	currStampGui.InsertPanel:TweenPosition(UDim2.new(0.2, 2, 0.1, 24),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
end

function closeInsertPanel()
	pcall(function() currStampGui.InsertPanel.CancelButton.Modal = false end)
	currStampGui.StamperPanel.StamperButtons.PartsButton.Selected = false
	currStampGui.InsertPanel:TweenPosition(UDim2.new(0.2, 2, 1, 24),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
end

function closeClonePanel()
	currStampGui.StamperPanel.StamperButtons.ClonePanel.ClonePanelText.Visible = false
	currStampGui.StamperPanel.StamperButtons.CloneButton.Selected = false
	currStampGui.StamperPanel.StamperButtons.ClonePanel:TweenPosition(UDim2.new(0, 0, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
	delay(0.3,function() currStampGui.StamperPanel.StamperButtons.ClonePanel.Visible = false end)
end

function cancelAssetPlacement()

	gInitial90DegreeRotations = 0
	Data.Stamp.Cancelled = true
	Data.Stamp.Dragger = nil
	if Data.Stamp.Model then
		Data.Stamp.Model:Remove()
		Data.Stamp.Model = nil
	end
	if Data.Stamp.CurrentParts then
		for index, object in pairs(Data.Stamp.CurrentParts) do
			object:Remove()
		end
		Data.Stamp.CurrentParts = nil
	end

	if Mouse then
		Mouse.Icon =&quot;rbxasset://textures\\ArrowCursor.png&quot;
	end
	game.JointsService:ClearJoinAfterMoveJoints()

end

function hint(label)

	-- Pass in a string, it shows a top hint.  (Replaces previous hint, if exists)
	_player = game.Players:GetPlayerFromCharacter(Tool.Parent)
	if(_player.PlayerGui:FindFirstChild(&quot;topHint&quot;)~=nil) then
		local topHint = _player.PlayerGui.topHint
		topHint.Add.Label.Value = label
		topHint.Add.Width.Value = 3 -- widest width
		topHint.Add.Time.Value = 5
		topHint.Add.Disabled = true
		topHint.Add.Disabled = false
	end

end

function getPlayer()
	return game.Players:GetPlayerFromCharacter(script.Parent.Parent)
end

function getHumanoid()
	local player = game.Players:GetPlayerFromCharacter(script.Parent.Parent)
	if player then
		waitForProperty(player,&quot;Character&quot;)
		waitForChild(player.Character,&quot;Humanoid&quot;)
		return player.Character.Humanoid
	else
		return nil
	end
end

function buildSetButton(name, setId, setImageId, i,  count)

	local button = currStampGui.InsertPanel.Sets.SetsLists.SetButtonExample:Clone()
	button.Text = name
	button.Name = &quot;SetButton&quot;
	button.Visible = true

	local setValue = Instance.new(&quot;IntValue&quot;)
	setValue.Name = &quot;SetId&quot;
	setValue.Value = setId
	setValue.Parent = button

	local setName = Instance.new(&quot;StringValue&quot;)
	setName.Name = &quot;SetName&quot;
	setName.Value = name
	setName.Parent = button

	return button
end


function previousSetPage()
	local newIndex = math.max(0, Data.Category[Data.CurrentCategory].Index - (InsertRows * InsertColumns))
	setSetIndex(newIndex)
end


function nextSetPage()
	local newIndex = math.max(0, Data.Category[Data.CurrentCategory].Index + (InsertRows * InsertColumns))
	setSetIndex(newIndex)
end

function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
	if visible then
		insertFrame.AssetName.Value = name
		insertFrame.AssetId.Value = assetId
		local newImageUrl = SmallThumbnailUrl  .. assetId
		if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
			insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
		end
		table.insert(insertButtonCons,
			insertFrame.Button.MouseButton1Click:connect(function()
				beginInsertAssetGui(insertFrame.AssetName.Value, insertFrame.AssetId.Value, insertFrame.Button.ButtonImage.Image, 1)
			end)
		)
		insertFrame.Visible = true
	else
		insertFrame.Visible = false
	end
end

function setSetIndex(dataOffset)

	Data.Category[Data.CurrentCategory].Index = dataOffset

	InsertRows = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
	InsertColumns = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

	local PageSize = InsertRows * InsertColumns
	local contents = Data.Category[Data.CurrentCategory].Contents
	if contents then
		
		local numOfPages = math.ceil((#contents)/(PageSize))
		local currPage = math.ceil((dataOffset/PageSize) + 1)
		currStampGui.InsertPanel.PagingControls.PageText.Text = tostring(currPage) .. &quot;/&quot; .. tostring(numOfPages)
		currStampGui.InsertPanel.PagingControls.PageText.Visible = (numOfPages &gt; 1)

      currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = (numOfPages &gt; 1) and dataOffset &gt; 1
		currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = (numOfPages &gt; 1) and ((dataOffset - 1) + PageSize) &lt; (#contents)

		-- remove our buttons and their connections
		for i = 1, #insertButtons do
			insertButtons[i]:remove()
		end
		for i = 1, #insertButtonCons do
			pcall(function() insertButtonCons[i]:disconnect() end)
		end

		insertButtonCons = {}
		insertButtons = {}
		local arrayPosition = 1
		for y = 1, InsertRows do
			for x = 1, InsertColumns do
				local buttonPosition = UDim2.new(0,(buttonWidth)*(x-1),0, (buttonHeight)*(y-1))

				local buttonCon
				insertButtons[arrayPosition], buttonCon = buildInsertButton(buttonPosition)
				table.insert(insertButtonCons,buttonCon)
				insertButtons[arrayPosition].Parent = currStampGui.InsertPanel.ItemsFrame
				arrayPosition = arrayPosition + 1
			end
		end

		Data.InsertButtons = insertButtons

		for index = 1, PageSize do
			if insertButtons[index] then
				if contents[index + dataOffset] then
					local assetId
					if useAssetVersionId then
						assetId = contents[index + dataOffset].AssetVersionId
					else
						assetId = contents[index + dataOffset].AssetId
					end
					setInsertButtonImageBehavior(insertButtons[index], true, contents[index + dataOffset].Name, assetId)
				else
					setInsertButtonImageBehavior(insertButtons[index], false)
				end
			end
		end
	else
		currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = false
		currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = false
	end

end

function moveLoadingLeft()
	if loading then
		currStampGui.LoadDialog.LoadLabel:TweenPosition(UDim2.new(0, 0, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.7,true,function() moveLoadingRight() end)
	end
end

function moveLoadingRight()
	if loading then
		currStampGui.LoadDialog.LoadLabel:TweenPosition(UDim2.new(0, 180, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.7,true,function() moveLoadingLeft() end)
	end
end

function moveLoadingWindow()
	currStampGui.LoadDialog.Visible = true
	loading = true
	moveLoadingRight()
end

function cancelLoadingWindow()
	currStampGui.LoadDialog.Visible = false
	loading = false
end


function selectCategoryPage(buttons, page)

	if buttons ~= Data.CurrentCategory then
		if Data.CurrentCategory then
			for key, button in pairs(Data.CurrentCategory) do
				button.Visible = false
			end
		end

		Data.CurrentCategory = buttons
		if Data.Category[Data.CurrentCategory] == nil then
			Data.Category[Data.CurrentCategory] = {}
			if #buttons &gt; 0 then
				selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
			end
		else
			Data.Category[Data.CurrentCategory].Button = nil
			selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
		end
		if Data.Main.FrameHeight then
			if Data.Category[Data.CurrentCategory].SetIndex then
				layoutSetButtons(Data.Main.FrameHeight, Data.Category[Data.CurrentCategory].SetIndex)
			else
				layoutSetButtons(Data.Main.FrameHeight, 1)
			end
		end
	end

end

function selectSet(button, setName, setId, setIndex)

	if button and Data.Category[Data.CurrentCategory] ~= nil then
		if button ~= Data.Category[Data.CurrentCategory].Button then
			Data.Category[Data.CurrentCategory].Button = button

			if SetCache[setId] == nil then
				SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
			end
			Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

			Data.Category[Data.CurrentCategory].SetName = setName
			Data.Category[Data.CurrentCategory].SetId = setId
		end
		setSetIndex(setIndex)
	end

end


function selectCategory(button, category)
	selectCategoryPage(category, 0)
end


function processCategory(sets, setPanel)
	local setButtons = {}
	local numSkipped = 0
	for index, object in pairs(sets) do
		if not showAdminCategories.Value and object.Name == &quot;Beta&quot; then
			-- skip this if not an admin
			numSkipped = numSkipped + 1
		else
			setButtons[index - numSkipped] = buildSetButton(object.Name, object.CategoryId, object.ImageAssetId, index - numSkipped, #sets)
			setButtons[index - numSkipped].Parent = setPanel
		end
	end
	return setButtons
end


function setsNextPageClick(totalSetPages, gridSize)
	-- set our logic/gui correctly
	if currSetPage &gt;= totalSetPages then return end

	currSetPage = currSetPage + 1
	currStampGui.InsertPanel.PagingControls.PageText.Text = tostring(currSetPage) .. &quot;/&quot; .. tostring(totalSetPages)
	if currSetPage == totalSetPages then
		currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = false
		currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = true
	else
		Window.Sets.PagingControls.NextPageButton.Visible = true
	end
	
	-- actually update the items
	makeCurrentSetsPageVisible(gridSize)
end

function setsPrevPageClick(totalSetPages, gridSize)
	-- set our logic/gui correctly
	if currSetPage &lt;= 1 then return end

	currSetPage = currSetPage - 1
	currStampGui.InsertPanel.PagingControls.PageText.Text = tostring(currSetPage) .. &quot;/&quot; .. tostring(totalSetPages)
	if currSetPage == 1 then
		currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = true
		currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = false
	else
		currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = true
	end

	-- actually update the items
	makeCurrentSetsPageVisible(gridSize)
end

function resetAllSetButtonSelection()
	local setButtons = Window.Sets.SetsLists:GetChildren()
	for i = 1, #setButtons do
		setButtons[i].Selected = false
		setButtons[i].BackgroundTransparency = 1
		setButtons[i].TextColor3 = Color3.new(1,1,1)
		setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
	end
end

function populateSetsFrame()
	local categories = #Data.UserCategoryButtons
	local robloxMaxCat = categories
	
	-- don&apos;t do anything until window is visible (otherwise we won&apos;t layout anything!)
	while Window.Sets.SetsLists.AbsoluteSize.X &lt;= 0 do
		Window.Sets.SetsLists.Changed:wait()
	end
	while Window.Sets.SetsLists.SetButtonExample.AbsoluteSize.X &lt;= 0 do
		Window.Sets.SetsLists.SetButtonExample.Changed:wait()
	end

	local totalColumns = math.floor(Window.Sets.SetsLists.AbsoluteSize.X/Window.Sets.SetsLists.SetButtonExample.AbsoluteSize.X)
	local totalRows = math.floor(Window.Sets.SetsLists.AbsoluteSize.Y/Window.Sets.SetsLists.SetButtonExample.AbsoluteSize.Y)
	
	local currRow = 0
	local buttonVisible = true

	local masterCategory = 1
	for i = 1, categories do
		local userCategory = masterCategory -- needed to maintain local scope for categories in event listeners below
		local button = Window.Sets.SetsLists.SetButtonExample:clone()

		button.Name = &quot;Set&quot; .. tostring(Data.UserCategoryButtons[userCategory].SetName.Value) .. &quot;Button&quot;
		button.Parent = Window.Sets.SetsLists
		button.Position = UDim2.new(0,5,0,currRow * button.AbsoluteSize.Y)
		button.Visible = buttonVisible
		button.Text =  tostring(Data.UserCategoryButtons[userCategory].SetName.Value)

		if i == 1 then
			button.Selected = true
			button.BackgroundColor3 = Color3.new(0,204/255,0)
			button.TextColor3 = Color3.new(0,0,0)
			button.BackgroundTransparency = 0
		end

		button.MouseEnter:connect(function()
			if not button.Selected then
				button.BackgroundTransparency = 0
				button.TextColor3 = Color3.new(0,0,0)
			end
		end)
		button.MouseLeave:connect(function()
			if not button.Selected then
				button.BackgroundTransparency = 1
				button.TextColor3 = Color3.new(1,1,1)
			end
		end)
		setButtonCons[i] = button.MouseButton1Click:connect(function()
			resetAllSetButtonSelection()
			button.Selected = not button.Selected
			button.BackgroundColor3 = Color3.new(0,204/255,0)
			button.TextColor3 = Color3.new(0,0,0)
			button.BackgroundTransparency = 0

			selectSet(button, button.Text, Data.UserCategoryButtons[userCategory].SetId.Value, 0)
		end)
		
		masterCategory = masterCategory + 1

		currRow = currRow + 1
	end
	
	-- don&apos;t use example button as the first set!
	local example = currStampGui.InsertPanel.Sets.SetsLists.SetButtonExample
	currStampGui.InsertPanel.Sets.SetsLists.SetButtonExample.Parent = nil
	local buttons =  currStampGui.InsertPanel.Sets.SetsLists:GetChildren()
	example.Parent = currStampGui.InsertPanel.Sets.SetsLists

	-- set first category as loaded for default
	selectSet(buttons[1], buttons[1].Text, Data.UserCategoryButtons[1].SetId.Value, 0)
	selectCategory(buttons[1], Data.UserCategoryButtons)
end


function layoutSetButtons(frameHeight, setIndex)
	Data.Main.FrameHeight = frameHeight
	Data.Main.InsertSets = math.floor(frameHeight / (height*2))
	if #Data.CurrentCategory &gt; Data.Main.InsertSets then
		--Steal one entry since we have too many things
		Data.Main.InsertSets = Data.Main.InsertSets - 1
	end

	Data.Category[Data.CurrentCategory].SetIndex = setIndex
end


function showLargePreview(insertButton)
	if insertButton:FindFirstChild(&quot;AssetId&quot;) then
		currStampGui.InsertPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
	end
	if insertButton:FindFirstChild(&quot;AssetName&quot;) then
		currStampGui.InsertPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
	end
end


function buildInsertButton(buttonPosition)
	local insertButton = currStampGui.InsertPanel.ItemsFrame.InsertAssetButtonExample:clone()
	insertButton.Position = buttonPosition
	insertButton.Name = &quot;InsertAssetButton&quot;
	insertButton.Visible = true

	local mouseEnterCon = insertButton.MouseEnter:connect(function()
		showLargePreview(insertButton)
	end)
	return insertButton, mouseEnterCon
end

function minimizeStamperPanel()
	currStampGui.StamperPanel.StamperButtons.Visible = false
	currStampGui.StamperPanel.MinimizeButton.Visible = false
	currStampGui.StamperPanel:TweenSizeAndPosition(UDim2.new(0,0,0,0), UDim2.new(0.5,0,1,-92),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.5,true)
	delay(0.5,function()
		currStampGui.StamperPanel.RestoreButton.Visible = true
	end)
end

function restoreStamperPanel()
	currStampGui.StamperPanel.RestoreButton.Visible = false
	currStampGui.StamperPanel:TweenSizeAndPosition(UDim2.new(0,350,0,48), UDim2.new(0.5,-175,1,-135), Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.5,true)
	delay(0.5,function()
		currStampGui.StamperPanel.StamperButtons.Visible = true
		currStampGui.StamperPanel.MinimizeButton.Visible = true
	end)
end

function setUpStamperGui()
	pcall(function() currStampGui.InsertPanel.CancelButton.Modal = true end)
	Window.Sets = currStampGui.InsertPanel.Sets

	cloneButtonCon = currStampGui.StamperPanel.StamperButtons.CloneButton.MouseButton1Click:connect(goToClone)
	partListClickCon = currStampGui.StamperPanel.StamperButtons.PartsButton.MouseButton1Click:connect(goToInsertPanel)

	Data.Main = {}
	Data.Category = {}
	Data.Stamp = {}

	Data.BaseCategoryButtons = {}
	local userData = {}
	for id = 1, #userIdsForStamperParts do
		local newUserData = game:GetService(&quot;InsertService&quot;):GetUserCategories(userIdsForStamperParts[id].Value)
		if newUserData and #newUserData &gt; 2 then
			-- start at #3 to skip over My Decals and My Models for each account
			for category = 3, #newUserData do
				table.insert(userData, newUserData[category])
			end
		end
	end
	
	if userData then
		Data.UserCategoryButtons = processCategory(userData, setPanel)

		--[[ bit of a hack to get rid of my models/decals -ben
		for i = 3,#Data.UserCategoryButtons do
			Data.UserCategoryButtons[i - 2] = Data.UserCategoryButtons[i]
		end
		Data.UserCategoryButtons[#Data.UserCategoryButtons] = nil
		Data.UserCategoryButtons[#Data.UserCategoryButtons] = nil]]
	end

	guiChangedCon = currStampGui.Changed:connect(function(prop)
		if prop == &quot;AbsoluteSize&quot; then
			wait()
			setSetIndex(0)
		end
	end)

	InsertRows = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
	InsertColumns = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

	populateSetsFrame()

	setsPrevPageCon = currStampGui.InsertPanel.PagingControls.PreviousPageButton.MouseButton1Click:connect(function() previousSetPage() end)
	setsNextPageCon = currStampGui.InsertPanel.PagingControls.NextPageButton.MouseButton1Click:connect(function() nextSetPage() end)

	insertPanelCloseCon = currStampGui.InsertPanel.CancelButton.MouseButton1Click:connect(function() closeInsertPanel() closeClonePanel() end)

	minimizeCon = currStampGui.StamperPanel.MinimizeButton.MouseButton1Click:connect(function() minimizeStamperPanel() end)
	restoreCon = currStampGui.StamperPanel.RestoreButton.MouseButton1Click:connect(function() restoreStamperPanel() end)
end

-- signal to scripts we are ready to start manipulating objects
function signalStamperScript(assetName, assetId, image, stampMode)
	insertAsset.AssetName.Value = assetName
	insertAsset.AssetId.Value = assetId
	insertAsset.Image.Value = image
	insertAsset.StampMode.Value = stampMode
	insertAsset.Updated.Value = true
end


function beginInsertAssetGui(assetName, assetId, image, stampMode)
	Data.Stamp.StampMode = stampMode
	closeInsertPanel()
	moveLoadingWindow()
	cancelAssetPlacement()
	signalStamperScript(assetName, assetId, image, stampMode)
end


function cancelAssetLoad()
	Data.Loading.Cancelled = true
	insertComplete()
	gInitial90DegreeRotations = 0
end

function inBounds2(part)
	-- part must have a position property
	local xOne= buildingPlate.Position.x + buildingPlate.Size.x/2
	local xTwo = buildingPlate.Position.x - buildingPlate.Size.x/2
	local zOne = buildingPlate.Position.z + buildingPlate.Size.z/2
	local zTwo = buildingPlate.Position.z - buildingPlate.Size.z/2
	if part.Position.x &gt; xOne or part.Position.x &lt; xTwo then return false end
	if part.Position.z &gt; zOne or part.Position.z &lt; zTwo then return false end
	return true
end


-- For Restricting Stamper Tool (isRestricted)
function showHelp_pointToBuildingplate()

	if(buildingPlate==nil) then
		hint(&quot;All building areas are taken. If you want to build, leave and join again.&quot;)
	else
		-- only show one waypoint at a time (because kids will click a million times outside their plate)
		hint(&quot;Stamper Tool only works in your area.&quot;)
		if(not waypointShowing) then
			waypointShowing = true
			local _character = Tool.Parent
			waitForChild(_character, &quot;Torso&quot;)
			_player = game.Players:GetPlayerFromCharacter(_character)
			_player.PlayerGui.showBaseplateWaypoint.target.Value = buildingPlate
			_player.PlayerGui.showBaseplateWaypoint.Disabled = true
			_player.PlayerGui.showBaseplateWaypoint.Disabled = false
			-- Wait until character moves in bounds (check every 2 seconds)
			while(not inBounds2(_character.Torso) and isEquipped) do	wait(2) end
			-- Then hide the waypoint
			hideHelp_pointToBuildingplate()
		end
	end

end


function showHelp_tooManyParts()
	hint(&quot;You have reached maximum number of parts! Delete some to put more down.&quot;)
end


function hideHelp_pointToBuildingplate()
	waypointShowing = false
	_player.PlayerGui.hideBaseplateWaypoint.Disabled = true
	_player.PlayerGui.hideBaseplateWaypoint.Disabled = false		
end


function setUpRestrictions()
	playerModel = game.Workspace.ActiveParts:FindFirstChild(player.Name .. &quot;&apos;s parts&quot;)

	local takenAreas = game.Workspace.BuildingAreas:GetChildren()

	waitForChild(player, &quot;playerNumber&quot;)
		
	if(player.playerNumber.Value == 0) then
	  buildingPlate = nil
	  partModel = nil
	else
	  waitForChild(game.Workspace, &quot;BuildingAreas&quot;)
	  local buildingAreas = game.Workspace.BuildingAreas
	  waitForChild(buildingAreas, &quot;Area&quot;..tostring(player.playerNumber.Value))
	  local targetArea = buildingAreas:FindFirstChild(&quot;Area&quot;..tostring(player.playerNumber.Value))
	  waitForChild(targetArea, &quot;PlayerArea&quot;)
	  waitForChild(targetArea.PlayerArea, &quot;BasePlate&quot;)

	  buildingPlate = targetArea.PlayerArea.BasePlate
	  partModel = targetArea.PlayerArea
			
	end

	-- Check if player is standing in bounds, if not show error
	local _character = Tool.Parent
	waitForChild(_character, &quot;Torso&quot;)
	_player = game.Players:GetPlayerFromCharacter(_character)
	if(buildingPlate~=nil) then
		if(not inBounds2(_character.Torso)) then
			showHelp_pointToBuildingplate()
		end
	else
		-- You have no building plate.
		hint(&quot;All building areas are taken. If you want to build, leave and join again.&quot;)
	end
end

function onInsertKeyDown(key)
	key = string.lower(key)

	-- go to mru buttons
	if key == &apos;f&apos; then
		mruButtonClick(1)
	elseif key == &apos;g&apos; then
		mruButtonClick(2)
	elseif key == &apos;h&apos; then
		mruButtonClick(3)
	elseif key == &apos;j&apos; then
		mruButtonClick(4)
	end

end

function onEquippedLocal(mouse)
	player = getPlayer()
	if not player then 
		return 
	end
	if Tool.PlayerOwner.Value and Tool.PlayerOwner.Value ~= player then return end 

	-- For Restricting Stamper Tool
	if isRestricted.Value then
		setUpRestrictions()
	end

	Mouse = mouse
	if not firstEquip and currStampGui and Tool.SavedState.Value and Tool.PlayerOwner.Value == getPlayer() and Data and Data.FullyLoaded then

		currStampGui.Parent = getPlayer().PlayerGui

		if mode == 1 then -- if we were stamping, keep going
			signalStamperScript(insertAsset.AssetName.Value, insertAsset.AssetId.Value, insertAsset.Image.Value, true)
		elseif mode == 2 then -- time to clone
			goToClone()
		end

	else
		if firstEquip then
			Tool.PlayerOwner.Value = player
			firstEquip = false
		end
		CancelDuringLoad = false
		resetCons()

		Data = {}
		Data.FullyLoaded = false
				
		Window = {}
		Window.Sets = {}

		currStampGui = stamperGui:clone()
		currStampGui.Parent = getPlayer().PlayerGui
		wait()
		setUpStamperGui()

		if not(CancelDuringLoad) then
			currStampGui.Parent = getPlayer().PlayerGui
			Tool.SavedState.Value = currStampGui
		end

		Data.FullyLoaded = true
	end

	Mouse.KeyDown:connect(onInsertKeyDown)
end


function onUnequippedLocal()
	if currStampGui then
		Tool.SavedState.Value = currStampGui
		currStampGui.Parent = nil
	end
	
	pcall(function()
		cancelAssetPlacement()
		Data.Loading.Cancelled = true
	end)
	CancelDuringLoad = true
end


function killConnection(connection)
	if connection then connection:disconnect() end
end


function resetCons()
	killConnection(guiChangedCon)
	killConnection(cloneButtonCon)
	killConnection(partListClickCon)
	killConnection(itemFrameChangedCon)
	killConnection(setsPrevPageCon)
	killConnection(setsNextPageCon)
	killConnection(insertPanelCloseCon)
	killConnection(minimizeCon)
	killConnection(restoreCon)
end


function onAncestryChanged(child,parent)
	if Tool.PlayerOwner.Value and not Tool:IsDescendantOf(Tool.PlayerOwner.Value) and not Tool:IsDescendantOf(Tool.PlayerOwner.Value.Character) then
		--Tool was dropped in some way, so we need to nuke our external state
		Tool.SavedState.Value = nil
		resetCons()
	end
end


function getMaxNumOfRecentParts()
	return maxRecentParts
end


function pushRecentStackBack()
	for i = getMaxNumOfRecentParts() - 1, 1, -1 do
		recentPartStack[i + 1].AssetNameValue = recentPartStack[i].AssetNameValue
		recentPartStack[i + 1].AssetIdValue = recentPartStack[i].AssetIdValue
		recentPartStack[i + 1].InsertFrameButtonImage = recentPartStack[i].InsertFrameButtonImage
	end
end


function clearMRUList()
	local buttons = currStampGui.StamperPanel.StamperButtons.RecentFrame:GetChildren()
	for i = 1, #buttons do
		if recentPartStackCons[i] then recentPartStackCons[i]:disconnect() end
		buttons[i].Visible = false
	end
end


function mruButtonClick(position)
	if recentPartStack[position].AssetIdValue == insertAsset.AssetId.Value then return end -- already stamping part
	-- get rid of old part
	signalStamperScript(&quot;&quot;,0,&quot;&quot;,&quot;&quot;,false)

	--Show the dialog window
	moveLoadingWindow()
	signalStamperScript(recentPartStack[position].AssetNameValue, recentPartStack[position].AssetIdValue, recentPartStack[position].InsertFrameButtonImage, true)
end


function insertMRUButton(position)
	local mruButton = currStampGui.StamperPanel.StamperButtons.RecentFrame:FindFirstChild(&quot;Button&quot; .. tostring(position))
	mruButton.ButtonImage.Image = recentPartStack[position].InsertFrameButtonImage
	if mruButton.ButtonImage.Image == &quot;&quot; then
		mruButton.Text = recentPartStack[position].AssetNameValue
	end

	if recentPartStackCons[position] then pcall(function() recentPartStackCons[position]:Disconnect() end) end
	recentPartStackCons[position] = mruButton.MouseButton1Click:connect(function() mruButtonClick(position) end)
	mruButton.Visible = true
end


function refreshRecentParts()
	if insertAsset.Image.Value == &quot;&quot; then return end -- we don&apos;t have an asset, get out of here
	if not recentPartStack then return end -- if somehow not created yet (recentPartStack[i] calls below were nil somehow)
	
	local numOfRecentParts = getMaxNumOfRecentParts()

	for i = 1,numOfRecentParts do
		if insertAsset.AssetId and recentPartStack[i] and insertAsset.AssetId.Value == recentPartStack[i].AssetIdValue then -- already have part, don&apos;t push back
			return
		end
	end

	pushRecentStackBack()

	-- update our stack to show previously allocated part
	recentPartStack[1].AssetNameValue = insertAsset.AssetName.Value
	recentPartStack[1].AssetIdValue = insertAsset.AssetId.Value
	recentPartStack[1].InsertFrameButtonImage =  insertAsset.Image.Value

	clearMRUList()

	for i = 1, numOfRecentParts do
		if recentPartStack[i] and recentPartStack[i].AssetIdValue ~= &quot;&quot; then
			insertMRUButton(i)
		end
	end
end


function updateGui(type)
	if type == &quot;Main&quot; then
		goToInsertPanel()
	elseif type == &quot;EyeDropper&quot; then
		goToClone()
	elseif type == &quot;SideDialog&quot; then
		goToStamp()
	end
end
----------------------------------------------------------------------------------------



-- Lua Start Execution
setAssetUrls()

Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)
Tool.AncestryChanged:connect(onAncestryChanged)

waitForChild(variables, &quot;SwitchLoaderToDialog&quot;)
variables.SwitchLoaderToDialog.Changed:connect(function(prop)
	if variables.SwitchLoaderToDialog.Value == true then
		updateGui(variables.SwitchLoaderToDialog.DialogType.Value)
		variables.SwitchLoaderToDialog.Value = false
	end

end)

waitForChild(variables, &quot;ShowInvalidPlacement&quot;)
variables.ShowInvalidPlacement.Changed:connect(function(prop)
	if variables.ShowInvalidPlacement.Value == true then
		showHelp_pointToBuildingplate()
		showBaseplateGuideArrows()
		variables.ShowInvalidPlacement.Value = false
	end
end)

waitForChild(variables, &quot;ShowMaxedOut&quot;)
variables.ShowMaxedOut.Changed:connect(function(prop)
	if variables.ShowMaxedOut.Value == true then
		showHelp_tooManyParts()
		variables.ShowMaxedOut.Value = false
	end
end)

waitForChild(variables, &quot;Stamped&quot;)
variables.Stamped.Changed:connect(function()
	if variables.Stamped.Value == true then
		refreshRecentParts()
	end
end)
----------------------------------------------------------------------------------------</ProtectedString>
			</Properties>
		</Item>
		<Item class="SelectionBox" referent="RBX103">
			<Properties>
				<Ref name="Adornee">null</Ref>
				<bool name="Archivable">true</bool>
				<int name="Color">21</int>
				<string name="Name">ErrorBox</string>
				<float name="Transparency">0</float>
				<bool name="Visible">false</bool>
			</Properties>
		</Item>
	</Item>
</roblox>